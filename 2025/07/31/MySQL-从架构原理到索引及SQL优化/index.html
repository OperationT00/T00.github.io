<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="T00">
    
    <title>
        
            MySQL--从架构原理到索引及SQL优化 |
        
        Keeping T00
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
        <link rel="shortcut icon" href="/images/logo.svg">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/fontawesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/regular.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/solid.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/font/css/brands.min.css">
    
        
            
                
<link rel="stylesheet" href="/css/custom.css">

            
        
    
    <script class="keep-theme-configurations">
    const KEEP = window.KEEP || {}
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en","path":"search.json"}
    KEEP.theme_config = {"base_info":{"primary_color":"#0066cc","title":"Keeping T00","author":"T00","avatar":"/images/avatar.svg","logo":"/images/logo.svg","favicon":"/images/logo.svg"},"menu":{"home":"/","archives":"/archives","tags":"/tags","categories":"/categories","links":"/links"},"first_screen":{"enable":true,"background_img":"/images/bg.svg","background_img_dark":"/images/bg.svg","description":"Keep writing and Keep loving.","hitokoto":false},"social_contact":{"enable":false,"links":{"github":null,"weixin":null,"qq":null,"weibo":null,"zhihu":null,"twitter":null,"x":null,"facebook":null,"email":null}},"scroll":{"progress_bar":true,"percent":true,"hide_header":true},"home":{"announcement":null,"category":false,"tag":false,"post_datetime":"updated"},"post":{"author_badge":{"enable":true,"level_badge":true,"custom_badge":["One","Two","Three"]},"word_count":{"wordcount":true,"min2read":false},"datetime_format":"YYYY-MM-DD HH:mm:ss","copyright_info":false,"share":false,"reward":{"enable":false,"img_link":null,"text":null,"icon":null}},"code_block":{"tools":{"enable":true,"style":"default"},"highlight_theme":"obsidian"},"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true,"layout":"right"},"website_count":{"busuanzi_count":{"enable":true,"site_uv":true,"site_pv":true,"page_pv":true}},"local_search":{"enable":true,"preload":true},"comment":{"enable":false,"use":"valine","valine":{"appid":null,"appkey":null,"server_urls":null,"placeholder":null},"gitalk":{"github_id":null,"github_admins":null,"repository":null,"client_id":null,"client_secret":null,"proxy":null},"twikoo":{"env_id":null,"region":null,"version":"1.6.39"},"waline":{"server_url":null,"reaction":false,"version":"3.3.2"},"giscus":{"repo":null,"repo_id":null,"category":"Announcements","category_id":null,"reactions_enabled":false},"artalk":{"server":null},"disqus":{"shortname":null}},"rss":{"enable":false},"lazyload":{"enable":true},"cdn":{"enable":true,"provider":"cdnjs"},"pjax":{"enable":true},"footer":{"since":2025,"word_count":true,"site_deploy":{"enable":false,"provider":"github","url":null},"record":{"enable":false,"list":[{"code":null,"link":null}]}},"inject":{"enable":true,"css":["/css/custom.css"],"js":[null]},"root":"","source_data":{},"version":"4.2.5"}
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"}
    KEEP.language_code_block = {"copy":"Copy code","copied":"Copied","fold":"Fold code block","folded":"Folded"}
    KEEP.language_copy_copyright = {"copy":"Copy copyright info","copied":"Copied","title":"Original post title","author":"Original post author","link":"Original post link"}
  </script>
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <i class="pjax-progress-icon fas fa-circle-notch fa-spin"></i>
    
</div>



<main class="page-container border-box">
    <!-- home first screen  -->
    

    <!-- page content -->
    <div class="page-main-content border-box">
        <div class="page-main-content-top">
            
<header class="header-wrapper">

    <div class="border-box header-content">
        <div class="left flex-start border-box">
            
                <a class="logo-image border-box" href="/">
                    <img src="/images/logo.svg">
                </a>
            
            <a class="site-name border-box" href="/">
               Keeping T00
            </a>
        </div>

        <div class="right border-box">
            <div class="pc border-box">
                <ul class="menu-list border-box">
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/">
                                
                                HOME
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/archives">
                                
                                ARCHIVES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/tags">
                                
                                TAGS
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/categories">
                                
                                CATEGORIES
                                
                            </a>
                            
                        </li>
                    
                        
                        <li class="menu-item flex-start border-box">
                            <a class="menu-text-color border-box" href="/links">
                                
                                LINKS
                                
                            </a>
                            
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="menu-text-color fas search fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile border-box flex-start">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list border-box">
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/">
                            
                            HOME
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/archives">
                            
                            ARCHIVES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/tags">
                            
                            TAGS
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/categories">
                            
                            CATEGORIES
                        </a>
                        
                    </label>
                    
                </li>
            
                
                <li class="drawer-menu-item border-box not-sub-menu">
                    <label class="drawer-menu-label border-box">
                        <a class="drawer-menu-text-color left-side flex-start border-box" href="/links">
                            
                            LINKS
                        </a>
                        
                    </label>
                    
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle border-box">

            <div class="main-content border-box">
                

                    
<div class="fade-in-down-animation">
    <div class="post-page-container border-box">
        <div class="post-content-container border-box">
            

            <div class="post-content-bottom border-box">
                
                    <div class="post-title">
                        MySQL--从架构原理到索引及SQL优化
                    </div>
                

                
                    <div class="post-header border-box">
                        
                            <div class="avatar-box border-box">
                                <img src="/images/avatar.svg">
                            </div>
                        
                        <div class="info-box">
                            <div class="author border-box">
                                <span class="name">T00</span>
                                
                                    <span class="author-badge">Lv2</span>
                                
                            </div>
                            <div class="meta-info border-box">
                                

<div class="post-meta-info-container border-box post">
    <div class="post-meta-info border-box">
        

        
            <span class="meta-info-item post-create-date">
                <i class="icon fa-solid fa-calendar-plus"></i>&nbsp;
                <span class="datetime">2025-07-31 12:23:05</span>
            </span>

            
                <span class="meta-info-item post-update-date">
                    <i class="icon fa-solid fa-file-pen"></i>&nbsp;
                    <span class="datetime" data-updated="Sat Aug 02 2025 00:22:37 GMT+0800">2025-08-02 00:22:37</span>
                </span>
            
        

        
            <span class="meta-info-item post-category border-box"><i class="icon fas fa-folder"></i>&nbsp;
                <ul class="post-category-ul">
                    
                            <li class="category-item"><a href="/categories/MySQL/">MySQL</a></li>
                        
                    
                </ul>
            </span>
        

        
            <span class="post-tag meta-info-item border-box">
                <ul class="post-tag-ul">
                    
                            <li class="tag-item"><span class="tag-separator"><i class="icon fas fa-hashtag"></i></span><a href="/tags/MySQL/">MySQL</a></li>
                        
                    
                </ul>
            </span>
        

        
        
            <span class="meta-info-item post-wordcount">
                <i class="icon fas fa-file-word"></i>&nbsp;<span>12.1k Words</span>
            </span>
        
        
        
            <span class="meta-info-item post-pv">
                <i class="icon fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
            </span>
        
    </div>

    
</div>

                            </div>
                        </div>
                    </div>
                

                <div class="post-content keep-markdown-body ">
                    

                    
                         <h1 id="体系结构-SQL执行过程"><a href="#体系结构-SQL执行过程" class="headerlink" title="体系结构&#x2F;SQL执行过程"></a>体系结构&#x2F;SQL执行过程</h1><blockquote>
<p>在实际开发中，我们写下的 SQL 并不会直接拿去执行，而是要经过 MySQL 内部多个组件的协作处理。这就像你发出一个“订单”，需要经过接单、分配、调度、执行等流程，最终才拿到结果。</p>
</blockquote>
<p>了解这些执行流程，是我们掌握 SQL 优化、索引调优和事务隔离等高级特性的前提。</p>
<p>下图为MySQL的体系结构：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731171706104.4xuumbq8zc.webp"
                         alt="image-20250731171706104" align="left" 
                 >

<p>我们编写的每一条SQL语句都会经过这个流程：</p>
<ol>
<li>建立连接：使用到MySQL中的连接器<ol>
<li>在真正建立 MySQL 会话之前，操作系统底层要先通过 TCP 协议建立连接，经历<strong>三次TCP握手</strong>。（这一步与MySQL的连接器无关）；</li>
<li>校验用户名和密码；</li>
<li>校验权限；</li>
<li>初始化会话。</li>
</ol>
</li>
<li>查询缓存（MySQL8.0已废弃，因为对于更新比较频繁的表，查询缓存命中率低）：key为SQL语句，value为查询结果。</li>
<li>分析器：分为<strong>词法分析</strong>和<strong>语法分析</strong>，对SQL语句拆分并做如下分析<ol>
<li>词法分析：提取关键字；</li>
<li>语法分析：语法校验，构建SQL语法树，便于后续模块读取字段。</li>
</ol>
</li>
<li>预处理：检验SQL语句中的表和字段是否存在，将<code>select *</code>中的<code>*</code>拓展为表上的所有列。</li>
<li>优化器：<ol>
<li>表里有多个索引时，决定用哪个索引；</li>
<li>SQL语句中有多表连接时，决定连接顺序。</li>
</ol>
</li>
<li>执行器：调用相应引擎接口执行SQL语句。</li>
<li>存储引擎（默认为InnoDB)：真实读写数据。</li>
<li>返回结果。</li>
</ol>
<blockquote>
<p><strong>TCP（Transmission Control Protocol）</strong> 是传输控制协议，它是一种<strong>面向连接、可靠传输、按顺序交付</strong>的数据传输协议。</p>
<p>TCP 在传输前需要先建立连接，这叫<strong>三次握手（Three-way Handshake）</strong>：</p>
<ol>
<li><strong>客户端 → 服务端</strong>：发送 SYN 请求（我要连你）</li>
<li><strong>服务端 → 客户端</strong>：返回 SYN + ACK（我知道你要连）</li>
<li><strong>客户端 → 服务端</strong>：发送 ACK 确认（我也知道你知道我要连）</li>
</ol>
</blockquote>
<p>接下来我们来介绍MySQL中的存储引擎。</p>
<h2 id="字段执行顺序"><a href="#字段执行顺序" class="headerlink" title="字段执行顺序"></a>字段执行顺序</h2><ol>
<li>from：查询操作首先肯定要先知道是查的哪张表</li>
<li>join：和from一起走</li>
<li>where：知道查哪张表后，才能根据条件检索对应的数据，过滤原始行</li>
<li>group by：按照字段分组</li>
<li>having：和聚合函数一起用的话，就执行函数后再过滤数据</li>
<li>select：到这数据库再决定返回什么数据</li>
<li>order by：返回需要的数据后才能排序</li>
<li>limit：最后才能截取，才知道你要哪几行</li>
</ol>
<p>搭建数据基础：from，join</p>
<p>预处理：where，gruop by，聚合。having</p>
<p>字段选取和加工：select，distinct</p>
<p>最后结果整理：order by，limit</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>对于存储引擎，我们可能比较陌生，但是<strong>引擎</strong>这个概念倒是家喻户晓。</p>
<p>对于舰载机、直升机、火箭来说，他们都有各自的引擎，是他们最为核心的组件。而我们在选择引擎的时候，需要在合适的场景，选择合适的存储引擎，就像在直升机上，我们不能选择舰载机的引擎一样。</p>
<p><strong>存储引擎</strong>就是<strong>存储数据、建立索引、更新&#x2F;查询数据</strong>等技术的实现方式 。存储引擎是基于<strong>表</strong>的，而不是基于库的，所以存储引擎也可被称为<strong>表类型</strong>。我们可以在创建表的时候，来<strong>指定选择的存储引擎</strong>，如果没有指定将自动选择默认的存储引擎。</p>
<ol>
<li><strong>建表时指定存储引擎</strong>：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">CREATE TABLE</span>  表名(</span><br><span class="line">字段<span class="number">1</span>  字段<span class="number">1</span>类型   [ COMMENT  字段<span class="number">1</span>注释 ] ,</span><br><span class="line"> ......</span><br><span class="line">字段n  字段n类型   [COMMENT  字段n注释 ] </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB   [ COMMENT  表注释 ] ;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查询当前数据库支持的存储引擎</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> engines;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731171839775.lw1es6xh8.webp"
                         alt="image-20250731171839775" 
                 >

<p>里面比较重要的引擎有：InnoDB、MyISAM、Memory。</p>
<ol start="3">
<li>查询建表语句</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create table</span> account;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731172313942.9o03kqhvcu.webp"
                         alt="image-20250731172313942" 
                 >

<p>我们之前建表的时候没有指定引擎，可见默认的存储引擎就是<strong>InnoDB</strong>。</p>
<p>上面我们介绍了<strong>什么是存储引擎</strong>，以及如何在建表时<strong>如何指定存储引擎</strong>，接下来我们就来介绍下来上面重点提到的三种存储引擎 InnoDB、MyISAM、Memory的特点。</p>
<h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p><strong>InnoDB</strong>是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB是<strong>默认的MySQL 存储引擎</strong>。</p>
<p><strong>特点：</strong></p>
<ol>
<li>支持<strong>事务</strong>；</li>
<li><strong>行级锁</strong>，提高并发访问性能； </li>
<li>支持<strong>外键</strong>FOREIGN KEY约束，保证数据的完整性和正确性。</li>
</ol>
<p>文件：</p>
<p>xxx.ibd：xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm-早期的 、sdi-新版的）、数据和索引。</p>
<p>参数：innodb_file_per_table</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731172748929.8dx6eezw1q.webp"
                         alt="image-20250731172748929" style="zoom:50%;" align="left"
                 >

<p>如果该参数开启，代表对于InnoDB引擎的表，每一张表都对应一个ibd文件。 我们直接打开MySQL的 数据存放目录：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731172834321.2ks854cfsv.webp"
                         alt="image-20250731172834321" 
                 >

<p>可以看到里面有很多的ibd文件，每一个ibd文件就对应一张表，比如：我们有一张表 account，就有这样的一个account.ibd文件，而在这个ibd文件中不仅存放<strong>表结构、数据，还会存放该表对应的索引信息</strong>。</p>
<p><strong>逻辑存储结构</strong>：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731172917009.70anadou0w.webp"
                         alt="image-20250731172917009" 
                 >

<p><strong>表空间</strong> : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。 </p>
<p><strong>段 :</strong> 表空间是由各个段组成的， 常见的段有<strong>数据段、索引段、回滚段</strong>等。InnoDB中对于段的管理，都是引擎<strong>自身完成</strong>，不需要人为对其控制，一个段中包含多个区。 </p>
<p><strong>区</strong> : 区是表空间的单元结构，<strong>每个区的大小为1M</strong>。 默认情况下， InnoDB存储<strong>引擎页大小为 16K</strong>， 即一个区中一共有<strong>64个连续的页。</strong> </p>
<p><strong>页</strong> : 页是组成区的最小单元，页也是InnoDB 存储<strong>引擎磁盘管理的最小单元</strong>，每个页的大小<strong>默 认为 16KB</strong>。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。 </p>
<p>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段(后面会详细介绍)。</p>
<h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p><strong>MyISAM</strong>是MySQL早期的默认存储引擎。</p>
<p><strong>特点：</strong> </p>
<ol>
<li><p><strong>不支持事务</strong>，不支持外键 </p>
</li>
<li><p>支持<strong>表锁</strong>，不支持行锁 </p>
</li>
<li><p><strong>访问速度快</strong></p>
</li>
</ol>
<h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p><strong>Memory引擎</strong>的表数据时存储在<strong>内存</strong>中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为<strong>临时表或缓存</strong>使用。</p>
<p>特点：</p>
<ol>
<li>内存存放<strong>hash索引</strong>（默认），检索速度快，适合做缓存</li>
<li><strong>表锁</strong></li>
</ol>
<h2 id="三者区别及特点"><a href="#三者区别及特点" class="headerlink" title="三者区别及特点"></a>三者区别及特点</h2><table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>Memory</th>
</tr>
</thead>
<tbody><tr>
<td>事务安全</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>锁机制</td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>支持外键</td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li>问：InnoDB引擎与MyISAM引擎的区别 ? <ol>
<li>InnoDB支持<strong>事务，外键，行级锁</strong>，而MyISAM不支持事务，外键，只有表锁，并发性能低。</li>
<li>InnoDB<strong>支持数据库异常崩溃后的安全恢复</strong>，依赖于<code>redo_log</code>，而MyISAM不支持。</li>
<li>InnoDB支持<strong>MVCC</strong>，而MyISAM不支持。</li>
</ol>
</li>
</ul>
<h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><p><strong>InnoDB:</strong> 是Mysql的默认存储引擎，支持事务、外键，行级锁，可以保证事务的完整性和高并发性能，所以成为了MySQL的默认引擎。 </p>
<p><strong>MyISAM ：</strong> 如果应用是以<strong>读操作和插入操作</strong>为主，只有<strong>很少的更新和删除</strong>操作，并且对事务<strong>的完整性、并发性要求不是很高</strong>，那么选择这个存储引擎是非常合适的。（MongoDB）</p>
<p><strong>MEMORY：<strong>将所有数据保存在</strong>内存</strong>中，<strong>访问速度快</strong>，通常用于<strong>临时表及缓存</strong>。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。（Redis）</p>
<h1 id="索引机制详解"><a href="#索引机制详解" class="headerlink" title="索引机制详解"></a>索引机制详解</h1><blockquote>
<p>**索引（index）**是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
</blockquote>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>索引其实就可以理解成<strong>查字典时的目录</strong>，在没有目录前，查一个字就是<strong>一页页</strong>地去翻，这就是<strong>全表扫描</strong>，<strong>用目录就是用索引</strong>。</p>
<p><strong>优势：<strong>提高数据</strong>检索的效率</strong>，<strong>降低数据库 的IO成本</strong>通过索引列对数据进行<strong>排序</strong>，降低 数据排序的成本，降低<strong>CPU的消耗</strong>。 </p>
<p><strong>劣势：<strong>索引列也是要</strong>占用空间</strong>的。 索引大大<strong>提高了查询效率</strong>，同时却也<strong>降低更新表的速度</strong>， 如对表进行INSERT、UPDATE、DELETE时，效率降低。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  [ <span class="keyword">UNIQUE</span> <span class="operator">|</span> FULLTEXT ]  INDEX  index_name  <span class="keyword">ON</span>  table_name  ( </span><br><span class="line">index_col_name,... ) ;</span><br></pre></td></tr></table></figure>

<p>索引名成规范一般为<code>idx_表名_字段名</code>.</p>
<p>完成以下要求：</p>
<p>A. name字段为姓名字段，该字段的值可能会重复，为该字段创建索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br></pre></td></tr></table></figure>

<p> B. phone手机号字段的值，是非空，且唯一的，为该字段创建唯一索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_phone <span class="keyword">on</span> tb_user(phone);</span><br></pre></td></tr></table></figure>

<p>C. 为profession、age、status创建联合索引。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status); </span><br></pre></td></tr></table></figure>

<p>D. 为email建立合适的索引来提升查询效率。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_email <span class="keyword">on</span> tb_user(email);</span><br></pre></td></tr></table></figure>

<h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span>  INDEX  <span class="keyword">FROM</span>  table_name ;</span><br></pre></td></tr></table></figure>

<p>下面查看一下我们刚刚创建的索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731203109372.1e8wwinj7t.webp"
                         alt="image-20250731203109372" 
                 >

<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span>  INDEX  index_name  <span class="keyword">ON</span>  table_name ;</span><br></pre></td></tr></table></figure>

<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p>MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用<strong>哈希表</strong>实现的, 只有<strong>精确匹配索引列的查询才有效, 不支持范围查询</strong></td>
</tr>
<tr>
<td>R-tree(空间索 引）</td>
<td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类 型，通常使用较少。</td>
</tr>
<tr>
<td>Full-text(全文 索引)</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于 Lucene,Solr,ES</td>
</tr>
</tbody></table>
<p>注意： 我们平常所说的索引，如果没有特别指明，都是指<strong>B+树</strong>结构组织的索引。</p>
<h2 id="为什么InnoDb使用B-树索引结构"><a href="#为什么InnoDb使用B-树索引结构" class="headerlink" title="为什么InnoDb使用B+树索引结构"></a>为什么InnoDb使用B+树索引结构</h2><p>从索引的介绍来看，不难知道，索引就是用来提升检索效率的，那可以实现快速搜索的数据结构有：哈希表，二叉树，红黑树，B树，B+树，接下来我们就一个个分析：</p>
<ol>
<li>hash表：用唯一的key来查对应的value，虽然很快，但是它没法做范围查询，也没法排序，如下图<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731201833524.45hz4l9n9g.webp"
                         alt="image-20250731201833524" 
                 >如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可 以通过链表来解决，<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731201844267.45hz4l9n9h.webp"
                         alt="image-20250731201844267" 
                 ></li>
<li>二叉排序树</li>
</ol>
<p>左节点小于右节点，右节点大于根，中序遍历是有序的，可以排序也可以范围查询，理想状态下如下图：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731174515320.45hz4l9n9d.webp"
                         alt="image-20250731174515320" style="zoom: 67%;" align= "left" 
                 >

<p>但是一旦按照主键顺序插入，它就会退化为链表，性能很差如下图：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731174522161.92qfyfnf2a.webp"
                         alt="image-20250731174522161" style="zoom: 67%;" align="left"
                 >

<p>这时你可能会想到二叉平衡树</p>
<ol start="3">
<li>二叉平衡树：在插入节点的时候，使用<strong>旋转</strong>使二叉树保证平衡，左右子树<strong>高度差不大于1</strong>，这样虽然能<strong>避免退化为链表</strong>，但是由于它会追求<strong>绝对平衡</strong>，会<strong>频繁旋转</strong>，在插入数据时，就会带来大量磁盘IO，<strong>降低性能</strong>。</li>
<li>红黑树：红黑树也是一种<strong>自平衡的二叉排序树</strong>，通过插入删除数据时，进行<strong>变色</strong>和<strong>旋转</strong>来保持平衡，它不追求绝对平衡，所以<strong>大大降低了旋转操作</strong>，但是它的本质是二叉树，<strong>一个节点只有两个孩子</strong>，存储<strong>大量</strong>数据时，树高很高，<strong>性能自然就没那么好</strong>。</li>
<li>B树：它是一种<strong>多路平衡排序树</strong>，相对于二叉树，B树每个节点可以有多个分支，即多叉，下面展示一个最大度数（max-degree）为5(5阶)的b-tree（每个节点最多存储4个key，5 个指针）：<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/btree.6m47jigj4c.gif"
                         alt="btree" 
                 ></li>
</ol>
<p>可以看见它的节点<strong>又存索引又存数据</strong>，所以一个节点<strong>存不了多少索引</strong>，数据量很大的时候，树还是会比较<strong>高</strong>；而且做<strong>范围查询</strong>时，需要<strong>回溯</strong>，<strong>效率很低</strong>。</p>
<ol start="6">
<li>B+树：它也是多路平衡排序树，而且它的<strong>非叶子节点上只存索引值</strong>，不存数据，那么单个节点能存的索引值就很多了，<strong>树高更低，性能更好</strong>；而且B+树会把所有数据存放在<strong>最下层叶子节点中，并且由双向链表连接</strong>，范围查询只需遍历链表，不用回溯。</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/b+tree.5fkwawrmiy.gif"
                         alt="b+tree" 
                 >

<ul>
<li>那B+树中具体是咋存储数据的呢？</li>
</ul>
<h2 id="聚集索引-vs-二级索引"><a href="#聚集索引-vs-二级索引" class="headerlink" title="聚集索引 vs 二级索引"></a>聚集索引 vs 二级索引</h2><blockquote>
<p>其实MySQL索引可以就分为<strong>聚集索引</strong>和<strong>二级索引</strong>（也可称为非聚集索引）。</p>
</blockquote>
<ul>
<li><strong>聚集索引：<strong>将</strong>数据存储与索引</strong>放到了一块，索引结构的叶子节点保存了<strong>行数据</strong>，必须有,而且只有一个（主键索引，由于主键在B+树中，决定了主键就是自增插入，可以避免<strong>页分裂</strong>带来的性能问题）。</li>
</ul>
<blockquote>
<p>聚集索引选取规则: 如果存在主键，主键索引就是聚集索引。 如果不存在主键，将使用<strong>第一个唯一（UNIQUE）索引</strong>作为聚集索引。 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引.</p>
</blockquote>
<ul>
<li><strong>二级索引：<strong>将</strong>数据与索引分开存储</strong>，索引结构的叶子节点关联的是对应的<strong>主键</strong>，可以存在多个，在查找的时候<strong>先查出当前对应的主键id</strong>再<strong>回表</strong>查出对应的行数据，所以叫二级节点。</li>
</ul>
<p>二者如下图：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731202311324.8l0e9um1hi.webp"
                         alt="image-20250731202311324" 
                 >

<p>接下来，我们来分析一下，当我们执行如下的SQL语句时，具体的查找过程是什么样子的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查 找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li>
<li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最 终找到10对应的行row。</li>
<li>最终拿到这一行的数据，直接返回即可。</li>
</ol>
<ul>
<li>思考：InnoDB主键索引的B+tree高度为多高呢?</li>
</ul>
<p>前面我们可以知道InnoDB的结构如下：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731172917009.70anadou0w.webp"
                         alt="image-20250731172917009" 
                 >

<p>然后一个节点占用一页，如下图：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731201758138.5fkwawrmkj.webp"
                         alt="image-20250731201758138" 
                 >



<p>假设: <strong>一行数据大小为1k</strong>，那么一页中可以存储16行这样的数据；InnoDB的指针占用6个字节的空间，主键如果为bigint，占用字节数为8。</p>
<p>高度为2的时候： <code>n * 8 + (n + 1) * 6 = 16*1024</code> , 算出n约为1170，总共就是<code>1170*16=18720 </code> 也就是说，如果树的高度为2，则可以存储 18000 多条记录。</p>
<p>高度为3： <code>1171 * 1171 * 16 = 21939856</code>也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p>
<p>这样变相的证明了B+树做为索引结构的优越性</p>
<h2 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h2><blockquote>
<p>前面说了这么多关于索引的理论知识，接下来，我们来介绍关于如何得知SQL性能好坏，以便于我们更好的使用索引。</p>
</blockquote>
<h3 id="慢日志查询"><a href="#慢日志查询" class="headerlink" title="慢日志查询"></a>慢日志查询</h3><blockquote>
<p><strong>慢查询日志</strong>记录了所有执行时间<strong>超过指定参数</strong>（<code>long_query_time</code>，单位：秒，默认10秒）的所有SQL语句的日志。</p>
</blockquote>
<p>MySQL的慢查询日志默认没有开启，我们可以查看一下系统变量 <code>slow_query_log</code>，判断是否开启</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731204017941.1e8wwinj7v.webp"
                         alt="image-20250731204017941" style="zoom:50%;" align="left"
                 >

<p>可以临时开启慢查询日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log<span class="operator">=</span><span class="string">&#x27;ON&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>也可以更改配置文件增加以下两条配置文件开启：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启MySQL慢日志查询开关</span></span><br><span class="line"><span class="string">slow_query_log=1</span></span><br><span class="line"> <span class="comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line"><span class="string">long_query_time=2</span></span><br></pre></td></tr></table></figure>

<p>配置过后一定要<strong>重启</strong>MySQL服务。</p>
<p>可以使用以下代码查看慢日志存储在哪</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log_file&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731205834539.1sfcndvu30.webp"
                         alt="image-20250731205834539" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731210057172.26lse944y5.webp"
                         alt="image-20250731210057172" 
                 >

<p>我们提前准备了一个<strong>千万数据表</strong><code>tb_sku</code>，来试着执行一条SQL</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_sku;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731210319228.6f0zo2udql.webp"
                         alt="image-20250731210319228" 
                 >

<p>可以看见日志里面就记录了这条sql语句。</p>
<h3 id="proile的使用"><a href="#proile的使用" class="headerlink" title="proile的使用"></a>proile的使用</h3><blockquote>
<p>show profiles 能够在做SQL优化时帮助我们了解时间都<strong>耗费到哪里</strong>去了。</p>
</blockquote>
<p>通过have_profiling 参数，能够看到当前MySQL是否支持profile操作</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731210503548.6t7fey2olq.webp"
                         alt="image-20250731210503548" style="zoom:50%;" align="left"
                 >

<p>如果没有开启，可以通过以下指令开启：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET profiling = 1;</span><br></pre></td></tr></table></figure>

<p>开关已经打开了，接下来，我们所执行的SQL语句，<strong>都会被MySQL记录</strong>，并记录执行时间消耗到哪儿去 了。</p>
<p> 我们直接执行如下的SQL语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;白起&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_sku;</span><br></pre></td></tr></table></figure>

<p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profiles; <span class="comment">-- 查看每一条SQL的耗时基本情况</span></span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731210926065.2obu2u5ij3.webp"
                         alt="image-20250731210926065" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;<span class="comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span></span><br></pre></td></tr></table></figure>

<p>可以看见具体的执行耗时，最长的就是执行：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731211044027.67xrsn88b4.webp"
                         alt="image-20250731211044027" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;  <span class="comment">-- 查看指定query_id的SQL语句CPU的使用情况</span></span><br></pre></td></tr></table></figure>

<h3 id="explain的使用"><a href="#explain的使用" class="headerlink" title="explain的使用"></a>explain的使用</h3><blockquote>
<p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行 过程中表如何连接和连接的顺</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 直接在select语句之前加上关键字 explain / desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件；</span><br></pre></td></tr></table></figure>

<p>准备三个表，我们来逐步演示每个字段的含义：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731220246432.7i0oyyq7m9.webp"
                         alt="image-20250731220246432" style="zoom:50%;" align="left"
                 >

<p>他们之间的关系如下：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731220418889.7eh318x4wi.webp"
                         alt="image-20250731220418889" style="zoom:50%;" align="left"
                 >

<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询每个学生的选课情况</span></span><br><span class="line">explain <span class="keyword">select</span> s.<span class="operator">*</span>,c.<span class="operator">*</span> <span class="keyword">from</span> student s,course c,student_course sc <span class="keyword">where</span> s.id<span class="operator">=</span>sc.studentid <span class="keyword">and</span> c.id<span class="operator">=</span>sc.courseid;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>id如果是相同的，从上而下的执行，如图就是先查s，后查sc，最后c</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731220732798.58hofh5h5f.webp"
                         alt="image-20250731220732798" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student s <span class="keyword">where</span> s.id <span class="keyword">in</span> (<span class="keyword">select</span> studentid <span class="keyword">from</span> student_course sc <span class="keyword">where</span> sc.courseid <span class="operator">=</span> (<span class="keyword">select</span> C.id <span class="keyword">from</span> course c <span class="keyword">where</span> c.name <span class="operator">=</span> <span class="string">&#x27;MySQL&#x27;</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>id不同大的先执行</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731222257691.4xuumbq903.webp"
                         alt="image-20250731222257691" 
                 >

<h4 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h4><blockquote>
<p>表示 SELECT 的类型，参考意义不大</p>
</blockquote>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><blockquote>
<p>表示连接类型，性能由好到差的连接类型为NULL、system、const、 eq_ref、ref、range、 index、all </p>
</blockquote>
<p>一般来说到<code>const</code>就是最好的了;</p>
<p><code>null</code>一般就是你给它什么，它查出什么，比如：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731222603384.b97lmrpck.webp"
                         alt="image-20250731222603384" 
                 >

<p><code>system</code>就是访问系统表；</p>
<p><code>const</code>就是访问主键或者索引：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731222844032.2obu2u5ij9.webp"
                         alt="image-20250731222844032" 
                 >

<p><code>ref</code>是非唯一性possible_key索引：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731222902026.6t7fey2olx.webp"
                         alt="image-20250731222902026" 
                 >

<h4 id="possible-key"><a href="#possible-key" class="headerlink" title="possible_key"></a>possible_key</h4><blockquote>
<p>顾名思义就是可能用到的索引。</p>
</blockquote>
<h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><blockquote>
<p>实际使用的索引，如果为NULL，则没有使用索引。</p>
</blockquote>
<h4 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h4><blockquote>
<p>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</p>
</blockquote>
<h4 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h4><blockquote>
<p>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值， 可能并不总是准确的。</p>
</blockquote>
<h4 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h4><blockquote>
<p>表示返回结果的行数占需读取行数的百分比， filtered的值<strong>越大越好</strong>。</p>
</blockquote>
<h4 id="Explain-执行计划中比较重要字段的含义"><a href="#Explain-执行计划中比较重要字段的含义" class="headerlink" title="Explain 执行计划中比较重要字段的含义:"></a>Explain 执行计划中比较重要字段的含义:</h4><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>表示连接类型</td>
</tr>
<tr>
<td>possible_key</td>
<td>显示可能应用在这张表上的索引，一个或多个。</td>
</tr>
<tr>
<td>key</td>
<td>实际使用的索引，如果为NULL，则没有使用索引。</td>
</tr>
<tr>
<td>key_len</td>
<td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长 度，在不损失精确性的前提下， 长度越短越好 。</td>
</tr>
</tbody></table>
<h2 id="索引实战"><a href="#索引实战" class="headerlink" title="索引实战"></a>索引实战</h2><p>接下俩我们开始实际探讨索引的使用及其一些特性。</p>
<h3 id="验证索引效率"><a href="#验证索引效率" class="headerlink" title="验证索引效率"></a>验证索引效率</h3><p>我们查询我们之前创建的千万行表的一条没有索引的数据，可以看见尽管只有一条数据，它也查询了15s之久。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731223744687.3rbjdq1ceu.webp"
                         alt="image-20250731223744687" 
                 >

<p>现在我们给它创建一个索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_sku_sn <span class="keyword">on</span> tb_sku(sn);</span><br></pre></td></tr></table></figure>

<p>可以看见有了索引之后，它几乎是瞬间查询出了数据：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731224005860.4n80t6b0uu.webp"
                         alt="image-20250731224005860" 
                 >

<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><blockquote>
<p>如果索引了多列（联合索引），要遵守最左前缀法则。</p>
</blockquote>
<p><strong>最左前缀法则</strong>指的是查询从索引的<strong>最左列开始</strong>， 并且<strong>不跳过</strong>索引中的列。如果跳跃某一列，索引将会<strong>部分失效(后面的字段索引失效)</strong>。</p>
<p>我们上面创建了一个联合索引<code>idx_user_pro_age_sta</code></p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801133600465.2a5ebyx7o7.webp"
                         alt="image-20250801133600465" 
                 >

<p>对于<strong>最左前缀法则</strong>指的是，查询时，最左变的列，也就是<code>profession</code>必须存在，否则索引<strong>全部失效</strong>。  </p>
<p>而且中间不能<strong>跳过某一列</strong>，否则该列<strong>后面的字段索</strong>引将失效；接下来，我们来演示几组案例，看一下具体的执行计划：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看见成功使用索引了，而且索引长度为54。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801133815832.5c1ad6yjvc.webp"
                         alt="image-20250801133815832" 
                 >

<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们删除最后一个字段</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也使用了索引，并且长度为49，<code>status</code>索引长度应该为5。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801133919976.67xrsn88bd.webp"
                         alt="image-20250801133919976" 
                 >

<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们再删除一个字段</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>依旧使用了索引，长度为47，<code>age</code>索引长度为2，<code>profession</code>索引长度为47.</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801134048219.5trc1rzxga.webp"
                         alt="image-20250801134048219" 
                 >

<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 我们只是用age和status查询</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为没有最左边的字段，所以就没有使用索引，索引失效。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801134220594.8s3m5a86xn.webp"
                         alt="image-20250801134220594" 
                 >

<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 那如果我们使用profession和status呢?</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看见也使用了索引，索引长度为<code>profession</code>的长度47，并没有<code>status</code>的索引，只是部分走了索引。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801134411095.2rvg0jyl97.webp"
                         alt="image-20250801134411095" 
                 >

<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 再执行以下代码，是否会走索引呢？</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span> <span class="keyword">and</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>；</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看见是走索引了，而且所有索引都走了，由此可见与条件的排列顺序其实是没有关系的。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135110527.32i9tpdtel.webp"
                         alt="image-20250801135110527" 
                 >

<h2 id="索引失效场景汇总"><a href="#索引失效场景汇总" class="headerlink" title="索引失效场景汇总"></a>索引失效场景汇总</h2><blockquote>
<p>索引不是在任何时候都会发生作用的，以下我们就会介绍很多种索引失效的场景。</p>
</blockquote>
<h3 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h3><blockquote>
<p>上面已经讲的很清楚了，这里不过多介绍。</p>
</blockquote>
<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><blockquote>
<p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询<strong>右侧</strong>的列索引失效。</p>
</blockquote>
<p>接下来演示一下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>走了索引，为profession和age的索引，因为status的在范围查询的右边，所以失效了。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135319322.2yynvzkqou.webp"
                         alt="image-20250801135319322" 
                 >

<ul>
<li>有没有规避的方法呢？</li>
</ul>
<p>有的，就是在业务允许的情况下，只使用<strong>类似于 &gt;&#x3D; 或 &lt;&#x3D; 这类</strong>。</p>
<blockquote>
<p>我们在把<code>&gt;</code>改成<code>&gt;=</code>，可以发现所有索引都被使用了。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135110527.32i9tpdtel.webp"
                         alt="image-20250801135110527" 
                 >

<h3 id="索引列运算-函数处理"><a href="#索引列运算-函数处理" class="headerlink" title="索引列运算&#x2F;函数处理"></a>索引列运算&#x2F;函数处理</h3><blockquote>
<p>当根据phone字段进行<strong>等值匹配</strong>查询时, 索引生效。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135523501.1e8wwinj8g.webp"
                         alt="image-20250801135523501" 
                 >

<blockquote>
<p>当根据phone字段进行<strong>函数运算操作</strong>之后，索引失效。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> <span class="built_in">substring</span>(phone,<span class="number">10</span>,<span class="number">2</span>) <span class="operator">=</span> <span class="string">&#x27;15&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135551279.54y2hrceg1.webp"
                         alt="image-20250801135551279" 
                 >

<h3 id="字段类型不匹配"><a href="#字段类型不匹配" class="headerlink" title="字段类型不匹配"></a>字段类型不匹配</h3><blockquote>
<p>字符串类型字段使用时，不加引号，索引将失效。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135523501.1e8wwinj8g.webp"
                         alt="image-20250801135523501" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="number">17799990015</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135551279.54y2hrceg1.webp"
                         alt="image-20250801135551279" 
                 >

<p>经过上面两组示例，我们会明显的发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数据库存<strong>在隐式类型转换</strong>，索引将失效。</p>
<h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><blockquote>
<p>如果<strong>仅仅是尾部</strong>模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
</blockquote>
<p>由于下面查询语句中，都是根据profession字段查询，符合<strong>最左前缀法则</strong>，联合索引是可以生效的， 我们主要看一下，模糊查询时，%加在关键字之前，和加在关键字之后的影响。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;软件%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135707889.73u983hwrl.webp"
                         alt="image-20250801135707889" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135750247.8adkgp6tcy.webp"
                         alt="image-20250801135750247" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="keyword">like</span> <span class="string">&#x27;%工%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801135806105.45zq75jxf.webp"
                         alt="image-20250801135806105" 
                 >

<p>经过上述的测试，我们发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字 前面加了%，索引将会失效。</p>
<h3 id="or连接条件"><a href="#or连接条件" class="headerlink" title="or连接条件"></a>or连接条件</h3><blockquote>
<p>用or分割开的条件， 如果or<strong>前的条件中的列有索引</strong>，而<strong>后面的列中没有索引</strong>，那么涉及的索引<strong>都不会被用到</strong>。</p>
</blockquote>
<p>下面的<code>age</code>没有索引，<code>phone</code>有索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801140029756.102h5nf8dg.webp"
                         alt="image-20250801140029756" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">=</span> <span class="string">&#x27;17799990017&#x27;</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">23</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由于<strong>age没有索引</strong>，所以即使id、phone有索引，<strong>索引也会失效</strong>。所以需要针对于age也要建立索引。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801140044011.83acl9knxh.webp"
                         alt="image-20250801140044011" 
                 >

<p>然后，我们可以对age字段建立索引，重新执行：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801140218812.7p3wuecd2e.webp"
                         alt="image-20250801140218812" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801140229935.6ikllsngh2.webp"
                         alt="image-20250801140229935" 
                 >

<p>最终，我们发现，当or连接的条件，左右两侧字段都有索引时，索引才会生效。</p>
<h3 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h3><blockquote>
<p>如果MySQL评估使用索引比全表更慢，则不使用索引。</p>
</blockquote>
<p><code>tb_user</code>表单数据如下：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801140321127.7eh318x4x4.webp"
                         alt="image-20250801140321127" 
                 >

<ul>
<li>首先查询基本整个表的数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990005&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看见走到是全表查询，这是因为MySQL自己判断，认为走全表查询比走索引更快。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801140539386.5trc1rzxgp.webp"
                         alt="image-20250801140539386" 
                 >

<ul>
<li>然后我们只查询后面几行数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> phone <span class="operator">&gt;=</span> <span class="string">&#x27;17799990015&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这时可以看见它走的就是索引了。</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801140522418.lw1es6xig.webp"
                         alt="image-20250801140522418" 
                 >

<p>经过测试我们发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样，这是为什么呢？ </p>
<p>就是因为MySQL在查询时，会<strong>评估使用索引的效率与走全表扫描的效率</strong>，如果走全表扫描更快，则<strong>放弃索引</strong>，走全表扫描。 </p>
<p>因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p>
<h2 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h2><p>把上述的 idx_user_age, idx_email 这两个之前测试使用过的索引直接删除。</p>
<p>然后我们创建profession的单列索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_pro <span class="keyword">on</span>  tb_user(profession);</span><br></pre></td></tr></table></figure>

<p>执行SQL :</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801142021404.361vrf6w4s.webp"
                         alt="image-20250801142021404" 
                 >

<blockquote>
<p>发现走的联合索引，我们可以看到，possible_keys中idx_user_pro_age_sta,idx_user_pro 这两个 索引都可能用到，最终MySQL选择了idx_user_pro_age_sta索引。这是MySQL自动选择的结果。</p>
</blockquote>
<p>那么，我们能不能在查询的时候，自己来指定使用哪个索引呢？ 答案是肯定的，此时就可以借助于 MySQL的SQL提示来完成。 接下来，介绍一下<strong>SQL提示</strong>。</p>
<blockquote>
<p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些<strong>人为的提示来达到优化操作的目的</strong>。 </p>
</blockquote>
<ol>
<li>use index ： 建议MySQL使用哪一个索引完成此次查询（仅仅是建议，mysql内部还会再次进 行评估）</li>
<li>ignore index ： 忽略指定的索引</li>
<li>force index ： 强制使用索引</li>
</ol>
<p>示例</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user use index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801142231159.icfh2dust.webp"
                         alt="image-20250801142231159" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user ignore index(idx_user_pro) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801142243208.3yer95nhv1.webp"
                         alt="image-20250801142243208" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user force index(idx_user_pro_age_sta) <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801142253902.7eh318x4xa.webp"
                         alt="image-20250801142253902" 
                 >

<h2 id="覆盖索引与回表"><a href="#覆盖索引与回表" class="headerlink" title="覆盖索引与回表"></a>覆盖索引与回表</h2><blockquote>
<p>覆盖索引是指<strong>查询使用了索引</strong>，并且需要返回的列，在该索引中<strong>已经全部能够找到</strong> 。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,profession,age, status <span class="keyword">from</span> tb_user  <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Using where; Using Index：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801142929129.2rvg0jyl9q.webp"
                         alt="image-20250801142929129" 
                 >

<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,profession,age, status, name <span class="keyword">from</span> tb_user  <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">31</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Using index condition：查找使用了索引，但是需要回表查询数据</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801143009438.8z6u0pucdr.webp"
                         alt="image-20250801143009438" 
                 >

<hr>
<p><code>Using where; Using index</code> 比<code>Using index condition</code>的性能高</p>
<p>因为，在<code>tb_user</code>表中有一个联合索引<code>idx_user_pro_age_sta</code>，该索引关联了三个字段  <code>profession</code>、<code>age</code>、<code>status</code>，而这个索引也是一个<strong>二级索引</strong>，所以叶子节点下面挂的是这一行的<strong>主键id</strong>。</p>
<p>所以当我们查询返回的数据在<code>id</code>、<code>profession</code>、<code>age</code>、<code>status</code> 之中，则直接走二级索引<strong>直接返回数据</strong>了。</p>
<p>如果<strong>超出这个范围</strong>，就需要拿到<strong>主键id</strong>，再去扫描聚集索引，再获取额外的数据 了，这个过程就是<strong>回表</strong>。</p>
<p>而我们如果一直使用<code>select * </code>查询返回<strong>所有字段</strong>值，很容易就会<strong>造成回表查询</strong>（除非是根据主键查询，此时只会扫描聚集索引）。</p>
<ol>
<li>根据id查询，直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801143259987.45zq75jxs.webp"
                         alt="image-20250801143259987" 
                 >

<ol start="2">
<li>执行SQL：selet id,name from tb_user where name &#x3D; ‘Arm’;</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801143331807.4cl700vsq9.webp"
                         alt="image-20250801143331807" 
                 >



<ol start="3">
<li>执行SQL：selet id,name,gender from tb_user where name &#x3D; ‘Arm’</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801143402140.6bhdqd1b1u.webp"
                         alt="image-20250801143402140" 
                 >

<p>由于在<code>name</code>的二级索引中，不包含<code>gender</code>，所以，需要<strong>两次索引</strong>扫描，也就是需要<strong>回表查询</strong>，性能相对较差一点。</p>
<ul>
<li>一张表, 有四个字段(id, username, password, status), 由于数据量大, 需要对 以下SQL语句进行优化, 该如何进行才是最优方案:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,username,password <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;itcast&#x27;</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li>答案: 针对于<code>username</code>, <code>password</code>建立<strong>联合索引</strong>, sql为:</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index  idx_user_name_pass <span class="keyword">on</span> tb_user(username,password); </span><br></pre></td></tr></table></figure>

<ul>
<li>这样可以避免上述的SQL语句出现<strong>回表</strong>查询。</li>
</ul>
<p><strong>尽量使用覆盖索引，减少<code>select *</code>。</strong> </p>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><blockquote>
<p>当字段类型为字符串（varchar，text，longtext等）时，有时候需要<strong>索引很长的字符串，这会让索引变得很大</strong>，查询时，<strong>浪费大量的磁盘IO</strong>， 影响查询效率；此时可以只将字符串的<strong>一部分前缀</strong>，建 立索引，这样可以大大<strong>节约索引空间</strong>，从而提高索引效率。</p>
</blockquote>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n)) ;</span><br></pre></td></tr></table></figure>

<ul>
<li>前缀长度</li>
</ul>
<p>可以根据索引的<strong>选择性</strong>来决定，而选择性是指<strong>不重复的索引值（基数）<strong>和数据表的记录</strong>总数的比值</strong>， 索引<strong>选择性越高则查询效率越高</strong>， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email)<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801143742210.7axh3j427m.webp"
                         alt="image-20250801143742210" 
                 >

<blockquote>
<p>我们使用<strong>substring函数</strong>，不断减少索引的长度，尽量让它又短，同时选择性又尽量大，最后发现截取到前五位是最好的。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email,<span class="number">1</span>,<span class="number">5</span>))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801145640438.102h5nf8dz.webp"
                         alt="image-20250801145640438" 
                 >

<p>这时我们就可以创建索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_email_5 <span class="keyword">on</span> tb_user(email(<span class="number">5</span>));</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801144119008.64e5uxf5mc.webp"
                         alt="image-20250801144119008" 
                 >

<p>前缀索引的查询流程：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801144341768.7snis45fsk.webp"
                         alt="image-20250801144341768" 
                 >

<p>step1：先在当前前缀索引中查询到这行数据的id</p>
<p>step2：回表查询到一整行的数据</p>
<p>step3：在这一行数据的email的值与条件对比，然后返回这个值</p>
<p>最后在前缀索引当中看下一个值是否对应的上，如果可以重复上述操作，直至没有相同的前缀为止</p>
<p>其实前缀索引就是一个<strong>时间换空间</strong>的过程。</p>
<h2 id="单列-联合索引"><a href="#单列-联合索引" class="headerlink" title="单列&amp;联合索引"></a>单列&amp;联合索引</h2><blockquote>
<p>单列索引：即一个索引只包含单个列。 联合索引：即一个索引包含了多个列。</p>
</blockquote>
<p>我们先来看看<code>tb_user</code>表中目前的索引情况:</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801144857685.pfnci008l.webp"
                         alt="image-20250801144857685" style="zoom:50%;" align="left"
                 >

<p>我们针对于name和phone进行查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> name,phone <span class="keyword">from</span> tb_user <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;吕布&#x27;</span> <span class="keyword">and</span> phone <span class="operator">=</span><span class="string">&#x27;17799990000&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看见实际使用的只有一个索引，此时是会回表查询的</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801145151456.1lc4ry9oom.webp"
                         alt="image-20250801145151456" 
                 >

<p>紧接着，我们再来创建一个phone和name字段的联合索引来查询一下执行计划。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone_name <span class="keyword">on</span> tb_user(phone,name);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看见就没有回表查询了</p>
</blockquote>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250801145640438.102h5nf8dz.webp"
                         alt="image-20250801145640438" 
                 >

<p>多个单列索引的组合在混合条件下查询是会进行回表的，这种时候我们既可以使用联合索引来优化。</p>
<h2 id="索引下推（ICP"><a href="#索引下推（ICP" class="headerlink" title="索引下推（ICP)"></a>索引下推（ICP)</h2><blockquote>
<p>索引下推就是把 <strong>WHERE 条件尽量</strong>“推”到索引<strong>扫描阶段</strong>，省掉无用回表：可以在索引遍历过程中，对索引中<strong>包含的字段先做判断</strong>，直接过滤掉不满足条件的记录，然后再去做回表，从而减少了回表次数，提升了性能。</p>
</blockquote>
<p>假设索引为  (name, age)，查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">user</span> <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;王%&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p>联合索引先按<code>name</code>排序，<code>name</code>一样再按<code>age</code>排序，如果是 name&#x3D;”张三” and age &gt; 18，这个就能使用联合索引的所有列. 不需要索引下推。</p>
<ul>
<li><p>无ICP</p>
<ul>
<li>这里走联合索引先筛选出姓名以王开头的用户</li>
<li>由于这里是模糊匹配，不是等值匹配，故获取所有以王开头的用户后, 他们的<strong>age不一定有序</strong>的</li>
<li>所以无法<strong>继续使用联合索引的特性来筛选age</strong>, 只能拿到以王开头的<strong>用户的id</strong>, 去<strong>回表</strong>, 然后再筛选出age&#x3D;30的人.</li>
</ul>
</li>
<li><p>有ICP</p>
<ul>
<li>走联合索引<strong>先筛选出姓名以王开头</strong>且<strong>同时age&#x3D;30的用户</strong></li>
<li>回表只需要根据他的id查即可</li>
</ul>
</li>
</ul>
<p>可以看到使用了索引下推后, 大大减少了回表操作。</p>
<h2 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h2><ol>
<li><p>针对于<strong>数据量较大</strong>，且查询<strong>比较频繁</strong>的列建立索引。 </p>
</li>
<li><p>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</p>
</li>
<li><p>尽量选择<strong>区分度高</strong>的列作为索引，例如身份证号建议建立索引，但是性别不建议。</p>
</li>
<li><p>字符串字段较长，可以建立前缀索引。 </p>
</li>
<li><p>尽量使用<strong>联合索引</strong>，<strong>减少单列索引</strong>，查询时，联合索引很多时候可以覆盖索引，避免回表，提高查询效率。</p>
</li>
<li><p>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p>
</li>
</ol>
<h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><blockquote>
<p>上面我们了解了索引的机制，以及使用原则，其实不难看出，索引就是为了优化select查询语句的，那剩下的SQL如何优化呢？下面就开始探究其他SQL的优化方法。</p>
</blockquote>
<h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>如果我们需要一次性往数据库表中插入多条记录，可以从以下三个方面进行优化。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert  into</span>  tb_test  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert  into</span>  tb_test  <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert  into</span>  tb_test  <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;jerry&#x27;</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h4 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Insert  into</span>  tb_test  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>如果数据量很大一条sql插入的数据最好不要超过1000条；往往来说500-1000比较合理。</p>
<h4 id="手动控制事务"><a href="#手动控制事务" class="headerlink" title="手动控制事务"></a>手动控制事务</h4><p>由于mysql中的事务提交方式是自动提交的，也就意味着执行一条sql语句后，它就会自动提交事务，频繁开启事务也会影响性能。</p>
<p>这时我们就可以手动管理事务的开启关闭，在多条sql执行之后再提交事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span>  transaction;</span><br><span class="line"><span class="keyword">insert  into</span>  tb_test  <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert  into</span>  tb_test  <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">5</span>,<span class="string">&#x27;Cat&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<h4 id="主键顺序插入"><a href="#主键顺序插入" class="headerlink" title="主键顺序插入"></a>主键顺序插入</h4><p>主键顺序插入，性能要高于乱序插入（详细在后面主键优化）。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主键乱序插入 : <span class="number">8</span>  <span class="number">1</span>  <span class="number">9</span>  <span class="number">21</span>  <span class="number">88</span>  <span class="number">2</span>  <span class="number">4</span>  <span class="number">15</span>  <span class="number">89</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">3</span>   </span><br><span class="line">主键顺序插入 : <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span>  <span class="number">15</span>  <span class="number">21</span>  <span class="number">88</span>  <span class="number">89</span></span><br></pre></td></tr></table></figure>

<h3 id="load"><a href="#load" class="headerlink" title="load"></a>load</h3><p>在<strong>批量插入大量数据</strong>的时候，<code>insert</code>就不那么好用了，这个时候，我们就要使用<code>load</code>指令来批量插入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/.../..&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated  <span class="keyword">by</span>  <span class="string">&#x27;,&#x27;</span>  lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> ;</span><br></pre></td></tr></table></figure>

<p>这是基本语法格式：这串命令的含义是把本地<code>/.../..</code>路径中的文件，每一个元素按照<code>,</code>分隔，每一行又<strong>换行</strong>分隔，最后插入到<code>tb_user</code>中。</p>
<p>其中的形式不定，可以根据实际情况改变，例子中的格式为：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731143142110.2326gjb26p.webp"
                         alt="image-20250731143142110" 
                 >

<h4 id="命令行中"><a href="#命令行中" class="headerlink" title="命令行中"></a>命令行中</h4><p>不管是cmd还是linux要使用load指令，首先必须要开启<code>local_infile</code>：</p>
<ol>
<li>直接用<code>local_infile=1</code>登录</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --local-infile=1 -u root -p</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>登录时附加<code>local_infile</code>，然后将其设置为1</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql --local-infile -u root -p</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> global local_infile = 1;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731134436542.6m47jigj4d.webp"
                         alt="image-20250731134436542" 
                 >

<p>可以用以下指令查看是否修改成功：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @@local_infile;</span><br></pre></td></tr></table></figure>

<h4 id="datagrip"><a href="#datagrip" class="headerlink" title="datagrip"></a>datagrip</h4><p>右键连接，选择<code>属性(properties)</code>，在右边的<code>高级（advanced）</code>，将<code>allowLoadLoaclInfile</code>设置为<code>true</code>。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731141731954.2rvg0jyl73.webp"
                         alt="image-20250731141731954" 
                 >

<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>最后插入一百万条数据用时14s，如果用insert要用十分钟左右，大大提升了性能。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731141951659.7eh318x4un.webp"
                         alt="image-20250731141951659" 
                 >

<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p>在上一小节，我们提到，主键顺序插入的性能是要高于乱序插入的。 这一小节，就来介绍一下具体的 原因，然后再分析一下主键又该如何设计。</p>
<p>在InnoDB存储引擎中，表数据都是根据<strong>主键顺序组织</strong>存放的，这种存储方式的表称为<strong>索引组织表</strong>。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731143316875.70anadotzm.webp"
                         alt="image-20250731143316875" 
                 >

<p>前面我们知道InnoDB的逻辑结构，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。</p>
<p>那也就意味着，一个页中所存储的行也是<strong>有限的</strong>，如果插入的数据行row在该页存储不小，将会<strong>存储到下一个页中</strong>，<strong>页与页之间会通过指针连接。</strong></p>
<h3 id="主键顺序插入-1"><a href="#主键顺序插入-1" class="headerlink" title="主键顺序插入"></a>主键顺序插入</h3><ol>
<li>从磁盘中申请页， 主键顺序插入</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144308757.2h8m7ejd1v.webp"
                         alt="image-20250731144308757" 
                 >

<ol start="2">
<li>第一个页没有满，继续往第一页插入</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144321990.26lse944wk.webp"
                         alt="image-20250731144321990" 
                 >

<ol start="3">
<li>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144339573.pfnci005x.webp"
                         alt="image-20250731144339573" 
                 >

<p>后续反复。</p>
<h3 id="乱序插入导致页分裂"><a href="#乱序插入导致页分裂" class="headerlink" title="乱序插入导致页分裂"></a>乱序插入导致页分裂</h3><ol>
<li>加入1#,2#页都已经写满了，存放了如图所示的数据</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144339573.pfnci005x.webp"
                         alt="image-20250731144339573" 
                 >

<ol start="2">
<li><p>此时再插入id为50的记录，我们来看看会发生什么现象</p>
<ol>
<li>由于索引结构的叶子节点是有顺序的。按照顺序，应该存储在47之后</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144522289.9rjpigay1j.webp"
                         alt="image-20250731144522289" 
                 >

<ol start="2">
<li>但是47所在的1#页，已经写满了，存储不了50对应的数据了。 那么此时会开辟一个新的页 3#。</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144736588.4qrmqw43iw.webp"
                         alt="image-20250731144736588" 
                 >

<ol start="3">
<li>但是并不会直接将50存入3#页，而是会将1#页后一半的数据，移动到3#页，然后在3#页，插入50。</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144745300.1lc4ry9om1.webp"
                         alt="image-20250731144745300" 
                 >
</li>
<li><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个 页，应该是3#， 3#的下一个页是2#。 所以，此时，需要<strong>重新设置链表指针</strong></p>
</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144754342.7plnwyml5.webp"
                         alt="image-20250731144754342" 
                 >

<p>上述的这种现象，称之为 <strong>“页分裂”</strong>，是比较<strong>耗费性能</strong>的操作。</p>
<h3 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h3><p>目前表中已有数据的索引结构(叶子节点)如下：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144912294.7zqqnjrl5m.webp"
                         alt="image-20250731144912294" 
                 >

<ol>
<li>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间 变得允许被其他记录声明使用。</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731144939337.b97lmrpaz.webp"
                         alt="image-20250731144939337" 
                 >

<ol start="2">
<li>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731145013565.lw1es6xgc.webp"
                         alt="image-20250731145013565" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731145051096.6bhdqd1azh.webp"
                         alt="image-20250731145051096" 
                 >

<ol start="3">
<li>删除数据，并将页合并之后，再次插入新的数据21，则直接插入3#页</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731145105697.9o03kqhvby.webp"
                         alt="image-20250731145105697" 
                 >

<p>这个里面所发生的合并页的这个现象，就称之为 <strong>“页合并”</strong>。</p>
<ul>
<li>**MERGE_THRESHOLD：**合并页的阈值，可以自己设置，在创建表或者创建索引时指定。</li>
</ul>
<h3 id="主键优化的原则"><a href="#主键优化的原则" class="headerlink" title="主键优化的原则"></a>主键优化的原则</h3><ol>
<li>满足业务需求的情况下，尽量降低主键的长度。 </li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。 </li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。 </li>
<li>业务操作时，避免对主键的修改</li>
</ol>
<h2 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h2><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>MySQL的排序，有两种方式：</p>
<ul>
<li><p>Using filesort : 通过<strong>表的索引或全表扫描</strong>，读取满足条件的数据行，然后在<strong>排序缓冲区sort  buffer中完成排序</strong>操作，<strong>所有不是通过索引直接返回</strong>排序结果的排序都叫FileSort 排序。 </p>
</li>
<li><p>Using index : 通过有序索引顺序扫描<strong>直接返回有序数据</strong>，这种情况即为 using index，<strong>不需要额外排序，操作效率高</strong>。</p>
</li>
</ul>
<p>我们首先只保留以下索引：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731151718465.4qrmqw43jc.webp"
                         alt="image-20250731151718465" 
                 >

<ol>
<li>只对<code>age</code>和<code>phone</code>升序排列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150318139.99tntv9kgv.webp"
                         alt="image-20250731150318139" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age，phone;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150315317.7zqqnjrl5q.webp"
                         alt="image-20250731150315317" 
                 >

<blockquote>
<p>因为他们都没有索引，所以都是Using filesort，性能不好。</p>
</blockquote>
<ol start="2">
<li>我们给他们创建联合索引</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_age_phone <span class="keyword">on</span> tb_user(age,phone); #默认两个升序</span><br></pre></td></tr></table></figure>

<p>再次执行：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150504363.7zqqnjrl5r.webp"
                         alt="image-20250731150504363" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150525323.2a5ebyx7mo.webp"
                         alt="image-20250731150525323" 
                 >

<blockquote>
<p>发现两次排序都是Using index，性能好。</p>
</blockquote>
<ol start="3">
<li>如果我们对<code>age</code>，<code>phone</code>均降序排列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>,phone <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150618795.7plnwymld.webp"
                         alt="image-20250731150618795" 
                 >

<blockquote>
<p>也是<code>Using index</code>，使用了反向扫描索引。</p>
</blockquote>
<ol start="4">
<li>如果我们先对<code>phone</code>升序排列，相同时再对<code>age</code>升序排列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> phone,age;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150712196.9o03kqhvc1.webp"
                         alt="image-20250731150712196" 
                 >

<blockquote>
<p>违背最左前缀法则，没有使用索引。(索引是age在前，是age先排，这里先给phone排压根找不到索引，就是最左前缀法则)</p>
</blockquote>
<ol start="5">
<li>如果我们先对<code>age</code>升序排列，再对<code>phone</code>降序排列</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> id,age,phone <span class="keyword">from</span> tb_user <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span> ,phone <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150801577.b97lmrpb6.webp"
                         alt="image-20250731150801577" 
                 >

<blockquote>
<p>使用了索引，但是没有完全使用，性能没有提升。</p>
</blockquote>
<p>为什么呢？</p>
<p>查看索引，可以看见他们<strong>两个字段的值都是A</strong>，表示是<strong>升序索引</strong>。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731150938837.3nrxg089nn.webp"
                         alt="image-20250731150938837" 
                 >

<blockquote>
<p>不难想到，创建索引的时候<strong>age和phone是绑定在一起的</strong>，先通过升序排列确定了age的顺序，但是phone要降序排序就会重新搜索排序，自然就没有使用到索引来提升性能了。</p>
</blockquote>
<p>那我们是否可以通过优化就让它可以降序排列呢？</p>
<p>是可以的，我们可以指定对应字段是升序还是降序。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_age_pho_ad <span class="keyword">on</span> tb_user(age <span class="keyword">asc</span>,phone <span class="keyword">desc</span> );</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731151135575.73u983hwpw.webp"
                         alt="image-20250731151135575" 
                 >

<blockquote>
<p>可以看见phone就成了降序索引。</p>
</blockquote>
<p>再次执行可以看见使用索引成功提升到了性能。</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731151152619.8vn83019lx.webp"
                         alt="image-20250731151152619" 
                 >

<h3 id="附：索引的结构"><a href="#附：索引的结构" class="headerlink" title="附：索引的结构"></a>附：索引的结构</h3><img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731151401495.7eh318x4va.webp"
                         alt="image-20250731151401495" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731151407493.96a1w5ghrb.webp"
                         alt="image-20250731151407493" 
                 >

<h3 id="order-by优化原则"><a href="#order-by优化原则" class="headerlink" title="order by优化原则"></a>order by优化原则</h3><ol>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。 </li>
<li>尽量使用覆盖索引。 </li>
<li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）。 </li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小  sort_buffer_size(默认256k)。</li>
</ol>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731151555813.icfh2duqv.webp"
                         alt="image-20250731151555813" style="zoom: 50%;" align="left"
                 >

<h2 id="gruop-by优化"><a href="#gruop-by优化" class="headerlink" title="gruop by优化"></a>gruop by优化</h2><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><ul>
<li>先删除掉所有索引。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> profession, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731153627187.7i0oyyq7l5.webp"
                         alt="image-20250731153627187" 
                 >

<blockquote>
<p>可以看见性能是不好的，没有使用到索引</p>
</blockquote>
<p>然后，我们在针对于 profession ， age， status 创建一个联合索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_user_pro_age_sta <span class="keyword">on</span> tb_user(profession,age,status);</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731153723552.70anadou0a.webp"
                         alt="image-20250731153723552" 
                 >

<blockquote>
<p>加上联合索引后，增强了性能。</p>
</blockquote>
<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只使用age组合</span></span><br><span class="line">explain <span class="keyword">select</span> age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731153813812.13m33d8b1n.webp"
                         alt="image-20250731153813812" 
                 >

<blockquote>
<p>使用索引失败，因为违反了最左前缀法则。</p>
</blockquote>
<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不使用status</span></span><br><span class="line">explain <span class="keyword">select</span> profession,age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">group</span> <span class="keyword">by</span> profession,age;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731153901107.9gwvpavpwr.webp"
                         alt="image-20250731153901107" 
                 >

<blockquote>
<p>也使用了索引，与最左前缀法则一致。</p>
</blockquote>
<hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先指定profession，再对age组合</span></span><br><span class="line">explain <span class="keyword">select</span> age, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user <span class="keyword">where</span> profession <span class="operator">=</span> <span class="string">&#x27;软件工程&#x27;</span> <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731154856359.9dd9rl2n70.webp"
                         alt="image-20250731154856359" 
                 >

<blockquote>
<p>这样也使用了索引，因为age在profession后面，profession相同的情况下，age就是有序的。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以，在分组操作中，我们需要通过以下两点进行优化，以提升性能： </p>
<ol>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ol>
<h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><blockquote>
<p>在数据量比较大时，如果进行limit分页查询，在查询时，<strong>越往后，分页查询效率越低</strong>。</p>
</blockquote>
<h3 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h3><img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731155448309.6pnth89lv1.webp"
                         alt="image-20250731155448309" 
                 >

<blockquote>
<p>通过测试我们会看到，确实越往后，分页查询效率越低，这就是分页查询的问题所在</p>
</blockquote>
<p>优化思路: 一般分页查询时，通过创建<strong>覆盖索引</strong>能够比较好地提高性能，可以通过<strong>覆盖索引加子查询形式</strong>进行优化。</p>
<ol>
<li>我们先用order by做为踏板使用主键索引<strong>查询id</strong></li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>,<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731155943072.2rvg0jyl7z.webp"
                         alt="image-20250731155943072" 
                 >

<blockquote>
<p>我们知道limit是在order by后执行的，先用order by对索引的检索，快速找到9000000，然后再去使用limit。</p>
</blockquote>
<ol start="2">
<li>嵌合select *</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731155743080.9dd9rl2n72.webp"
                         alt="image-20250731155743080" 
                 >

<blockquote>
<p>不支持，那只有使用连表查询了。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a.<span class="operator">*</span> <span class="keyword">from</span> tb_sku a, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>,<span class="number">10</span>) b <span class="keyword">where</span> a.id <span class="operator">=</span> b.id;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731160011594.7snis45fqn.webp"
                         alt="image-20250731160011594" 
                 >

<p>提升了近50%的效率，还是很可观了。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol>
<li>通过覆盖索引查询主键id</li>
<li>再通过连表查询的方式回表查询行数据</li>
</ol>
<h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><blockquote>
<p>在之前的测试中，我们发现，如果数据量很大，在执行count操作时，是非常耗时的。 </p>
</blockquote>
<ul>
<li><p>MyISAM引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个 数，效率很高； 但是如果是带条件的count，MyISAM也慢。</p>
</li>
<li><p>InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出 来，然后累积计数。</p>
</li>
</ul>
<p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数 据库进行,但是如果是带条件的count又比较麻烦了)。</p>
<h3 id="count用法"><a href="#count用法" class="headerlink" title="count用法"></a>count用法</h3><p>count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的<strong>参数不是NULL</strong>，累计值就加 1，否则不加，最后返回累计值。</p>
<p>用法：count（*）、count（主键）、count（字段）、count（数字）</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>count(主 键)</td>
<td>InnoDB 引擎会<strong>遍历整张表</strong>，把每一行的<strong>主键id值都取出来</strong>，返回给服务层。 服务层拿到主键后，<strong>直接</strong>按行进行累加(主键不可能为null)。</td>
</tr>
<tr>
<td>count(字 段)</td>
<td>1.没有not null约束 : InnoDB引擎会<strong>遍历整张表</strong>把每一行的字段值都取出来，返回给服务层，服务层<strong>判断</strong>是否为null，不为null，计数累加。2.有not null 约束：InnoDB引擎会<strong>遍历</strong>整张表把每一行的字段值都取出来，返 回给服务层，<strong>直接</strong>按行进行累加。</td>
</tr>
<tr>
<td>count(数 字)</td>
<td>InnoDB引擎<strong>遍历</strong>整张表，但<strong>不取值</strong>。服务层对于返回的每一行，放一个数字“1” 进去，<strong>直接按行进行累加</strong>。</td>
</tr>
<tr>
<td>count(*)</td>
<td>InnoDB引擎并<strong>不会</strong>把全部字段取出来，而是专门做了<strong>优化</strong>，<strong>不取值</strong>，服务层<strong>直接按行进行累加</strong>。</td>
</tr>
</tbody></table>
<p>按照效率排序的话，count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(<em>)，所以尽 量使用 count(</em>)。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>尽量使用<strong>count(*)</strong>。</p>
<h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><blockquote>
<p>InnoDB是行级锁，是对索引加的锁，不是针对记录加的锁： 如果<strong>where条件是不带索引的字段</strong>,，那么就会是表锁.；如果where条件是<strong>带索引的字段</strong>, 那么是<strong>行锁</strong>. 并且该索引<strong>不能失效</strong>, 否则会从行锁<strong>升级为表锁</strong>。表锁的并发性能低。</p>
</blockquote>
<h3 id="实践-3"><a href="#实践-3" class="headerlink" title="实践"></a>实践</h3><p>先看一下我们的course表结构：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731170314777.3rbjdq1cdu.webp"
                         alt="image-20250731170314777" style="zoom:50%;" align="left"
                 >

<p>然后针对于这表创建两个会话：</p>
<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731170427179.8l0e9um1gy.webp"
                         alt="image-20250731170427179" 
                 >

<ol>
<li>两会话均是<strong>where有索引</strong>的更新</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;JavaEE&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731170727413.86tyizdqlv.webp"
                         alt="image-20250731170727413" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;MQ&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731170738579.7lkawojab8.webp"
                         alt="image-20250731170738579" 
                 >

<blockquote>
<p>他们是可以同时更新数据的，互不影响，并发性能好。</p>
</blockquote>
<hr>
<ol start="2">
<li>针对于没有索引的name字段更新</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话1</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;SpringBoot&#x27;</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;PHP&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731171230403.6bhdqd1b05.webp"
                         alt="image-20250731171230403" 
                 >

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 会话2</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> course <span class="keyword">set</span> name <span class="operator">=</span> <span class="string">&#x27;Kafka&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731171119336.mdshch6c.webp"
                         alt="image-20250731171119336" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731171248525.175p131drq.webp"
                         alt="image-20250731171248525" 
                 >

<blockquote>
<p>可以看见会话1执行过后，由于没有索引，所以开启了表锁，会话2直接无法更新，被卡住了进程。</p>
</blockquote>
<ol start="3">
<li>创建name索引重新执行</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_course_name <span class="keyword">on</span> course(name);</span><br></pre></td></tr></table></figure>

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731171549990.8s3m5a86wm.webp"
                         alt="image-20250731171549990" 
                 >

<img    
                       lazyload
                       alt="image"
                       data-src="https://OperationT00.github.io/picx-images-hosting/blog-assets-DB/image-20250731171608831.70anadou0n.webp"
                         alt="image-20250731171608831" 
                 >

<blockquote>
<p>是没有问题的。</p>
</blockquote>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>执行更新操作时，where条件尽量用有索引的字段。</p>
<h2 id="where优化"><a href="#where优化" class="headerlink" title="where优化"></a>where优化</h2><blockquote>
<p>同前面索引失效的情况，总结如下：</p>
</blockquote>
<p>应尽量避免在 where 子句中<strong>使用!&#x3D;或&lt;&gt;操作符</strong>，否则将引擎放弃使 用索引而进行全表扫描。</p>

                    
                </div>

                

                <div class="post-bottom-tags-and-share border-box">
                    <div>
                        
                            <ul class="post-tags-box border-box">
                                
                                    <li class="tag-item border-box">
                                        <i class="icon fas fa-hashtag"></i>&nbsp;<a href="/tags/MySQL/">MySQL</a>
                                    </li>
                                
                            </ul>
                        
                    </div>
                    <div>
                        
                    </div>
                </div>

                

                
                    <div class="post-nav border-box">
                        
                            <div class="prev-post">
                                <a class="prev"
                                   rel="prev"
                                   href="/2025/08/04/MySQL-%E8%A7%86%E5%9B%BE%E3%80%81%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%8F%8A%E8%A7%A6%E5%8F%91%E5%99%A8/"
                                   title="MySQL--视图、存储过程及触发器"
                                >
                                    <span class="left arrow-icon flex-center">
                                        <i class="fas fa-chevron-left"></i>
                                    </span>
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">MySQL--视图、存储过程及触发器</span>
                                        <span class="post-nav-item">Prev posts</span>
                                    </span>
                                </a>
                            </div>
                        
                        
                            <div class="next-post">
                                <a class="next"
                                   rel="next"
                                   href="/2025/07/31/MySQL-%E5%9F%BA%E7%A1%80%E7%AF%87/"
                                   title="MySQL--基础篇"
                                >
                                    <span class="title flex-center">
                                        <span class="post-nav-title-item text-ellipsis">MySQL--基础篇</span>
                                        <span class="post-nav-item">Next posts</span>
                                    </span>
                                    <span class="right arrow-icon flex-center">
                                        <i class="fas fa-chevron-right"></i>
                                    </span>
                                </a>
                            </div>
                        
                    </div>
                

                
                    






                
            </div>
        </div>

        
            <div class="pc-post-toc right-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-SQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">体系结构&#x2F;SQL执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">字段执行顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB"><span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM"><span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory"><span class="nav-text">Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-text">三者区别及特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9"><span class="nav-text">选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">索引机制详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-text">创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="nav-text">查看索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-text">删除索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-text">索引分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDb%E4%BD%BF%E7%94%A8B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-text">为什么InnoDb使用B+树索引结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-vs-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-text">聚集索引 vs 二级索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">SQL性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2"><span class="nav-text">慢日志查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proile%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">proile的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explain%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">explain的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#id"><span class="nav-text">id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-type"><span class="nav-text">select_type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type"><span class="nav-text">type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#possible-key"><span class="nav-text">possible_key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key"><span class="nav-text">key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key-len"><span class="nav-text">key_len</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rows"><span class="nav-text">rows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filtered"><span class="nav-text">filtered</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%AD%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E5%AD%97%E6%AE%B5%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-text">Explain 执行计划中比较重要字段的含义:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AE%9E%E6%88%98"><span class="nav-text">索引实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E7%B4%A2%E5%BC%95%E6%95%88%E7%8E%87"><span class="nav-text">验证索引效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-text">最左前缀原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%B1%87%E6%80%BB"><span class="nav-text">索引失效场景汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="nav-text">最左前缀法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-text">范围查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%90%E7%AE%97-%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86"><span class="nav-text">索引列运算&#x2F;函数处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="nav-text">字段类型不匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-text">模糊查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#or%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6"><span class="nav-text">or连接条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83"><span class="nav-text">数据分布</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%8F%90%E7%A4%BA"><span class="nav-text">SQL提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%9B%9E%E8%A1%A8"><span class="nav-text">覆盖索引与回表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%88%97-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-text">单列&amp;联合索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%88ICP"><span class="nav-text">索引下推（ICP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-text">索引设计原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="nav-text">SQL优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#insert"><span class="nav-text">insert</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="nav-text">批量插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1"><span class="nav-text">手动控制事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="nav-text">主键顺序插入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load"><span class="nav-text">load</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD"><span class="nav-text">命令行中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datagrip"><span class="nav-text">datagrip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA"><span class="nav-text">演示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="nav-text">主键优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5-1"><span class="nav-text">主键顺序插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B1%E5%BA%8F%E6%8F%92%E5%85%A5%E5%AF%BC%E8%87%B4%E9%A1%B5%E5%88%86%E8%A3%82"><span class="nav-text">乱序插入导致页分裂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E5%90%88%E5%B9%B6"><span class="nav-text">页合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-text">主键优化的原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#order-by%E4%BC%98%E5%8C%96"><span class="nav-text">order by优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%EF%BC%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">附：索引的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#order-by%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="nav-text">order by优化原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gruop-by%E4%BC%98%E5%8C%96"><span class="nav-text">gruop by优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-1"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#limit%E4%BC%98%E5%8C%96"><span class="nav-text">limit优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-2"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#count%E4%BC%98%E5%8C%96"><span class="nav-text">count优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#count%E7%94%A8%E6%B3%95"><span class="nav-text">count用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update%E4%BC%98%E5%8C%96"><span class="nav-text">update优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-3"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where%E4%BC%98%E5%8C%96"><span class="nav-text">where优化</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        
    </div>
</div>


                
            </div>
        </div>

        <div class="page-main-content-bottom border-box">
            
<footer class="footer border-box">
    <div class="copyright-info info-item">
    &copy;&nbsp;2025
    
            &nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;&nbsp;<a href="/">T00</a>
        
    </div>

    <div class="theme-info info-item">
        Powered by&nbsp;<a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;&&nbsp;Theme&nbsp;<a class="keep-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep</a>
    </div>

    

    
        <div class="count-info info-item">
            
                <span class="count-item border-box word">
                    <span class="item-type border-box">Total words</span>
                    <span class="item-value border-box word">47.6k</span>
                </span>
            

            
                <span class="count-item border-box uv">
                    <span class="item-type border-box">Unique Visitor</span>
                    <span class="item-value border-box uv" id="busuanzi_value_site_uv"></span>
                </span>
            

            
                <span class="count-item border-box pv">
                    <span class="item-type border-box">Page View</span>
                    <span class="item-value border-box pv" id="busuanzi_value_site_pv"></span>
                </span>
            
        </div>
    

    
</footer>

        </div>
    </div>

    <!-- post tools -->
    
        <div class="post-tools right-toc">
            <div class="post-tools-container border-box">
    <ul class="post-tools-list border-box">
        <!-- PC encrypt again -->
        

        <!-- PC TOC show toggle -->
        
            <li class="tools-item flex-center toggle-show-toc">
                <i class="fas fa-list"></i>
            </li>
        

        <!-- PC go comment -->
        

        <!-- PC full screen -->
        <li class="tools-item flex-center full-screen">
            <i class="fa-solid fa-expand"></i>
        </li>
    </ul>
</div>

        </div>
    

    <!-- side tools -->
    <div class="side-tools">
        <div class="side-tools-container border-box ">
    <ul class="side-tools-list side-tools-show-handle border-box">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <!-- toggle mode -->
        
            <li class="tools-item tool-toggle-theme-mode flex-center">
                <i class="fas fa-moon"></i>
            </li>
        

        <!-- rss -->
        

        <!-- to bottom -->
        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list border-box">
        
            <li class="tools-item toggle-show-toc-tablet flex-center">
                <i class="fas fa-list"></i>
            </li>
        

        

        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>

        <li class="tools-item tool-scroll-to-top flex-center show-arrow">
            <i class="arrow fas fa-arrow-up"></i>
            <span class="percent"></span>
        </li>
    </ul>
</div>

    </div>

    <!-- image mask -->
    <div class="zoom-in-image-mask">
    <img class="zoom-in-image">
</div>


    <!-- local search -->
    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="close-popup-btn">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

    <!-- tablet toc -->
    
        <div class="tablet-post-toc-mask">
            <div class="tablet-post-toc">
                <div class="post-toc-wrap border-box">
    <div class="post-toc border-box">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84-SQL%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="nav-text">体系结构&#x2F;SQL执行过程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="nav-text">字段执行顺序</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-text">存储引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB"><span class="nav-text">InnoDB</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyISAM"><span class="nav-text">MyISAM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Memory"><span class="nav-text">Memory</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E8%80%85%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-text">三者区别及特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%89%E6%8B%A9"><span class="nav-text">选择</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="nav-text">索引机制详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95"><span class="nav-text">创建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="nav-text">查看索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-text">删除索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-text">索引分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88InnoDb%E4%BD%BF%E7%94%A8B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-text">为什么InnoDb使用B+树索引结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-vs-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-text">聚集索引 vs 二级索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">SQL性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%85%A2%E6%97%A5%E5%BF%97%E6%9F%A5%E8%AF%A2"><span class="nav-text">慢日志查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#proile%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">proile的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#explain%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">explain的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#id"><span class="nav-text">id</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#select-type"><span class="nav-text">select_type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#type"><span class="nav-text">type</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#possible-key"><span class="nav-text">possible_key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key"><span class="nav-text">key</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#key-len"><span class="nav-text">key_len</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#rows"><span class="nav-text">rows</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filtered"><span class="nav-text">filtered</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Explain-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%AD%E6%AF%94%E8%BE%83%E9%87%8D%E8%A6%81%E5%AD%97%E6%AE%B5%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-text">Explain 执行计划中比较重要字段的含义:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AE%9E%E6%88%98"><span class="nav-text">索引实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E7%B4%A2%E5%BC%95%E6%95%88%E7%8E%87"><span class="nav-text">验证索引效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99"><span class="nav-text">最左前缀原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF%E6%B1%87%E6%80%BB"><span class="nav-text">索引失效场景汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="nav-text">最左前缀法则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="nav-text">范围查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%90%E7%AE%97-%E5%87%BD%E6%95%B0%E5%A4%84%E7%90%86"><span class="nav-text">索引列运算&#x2F;函数处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%8C%B9%E9%85%8D"><span class="nav-text">字段类型不匹配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="nav-text">模糊查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#or%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6"><span class="nav-text">or连接条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83"><span class="nav-text">数据分布</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%8F%90%E7%A4%BA"><span class="nav-text">SQL提示</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%B8%8E%E5%9B%9E%E8%A1%A8"><span class="nav-text">覆盖索引与回表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%88%97-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-text">单列&amp;联合索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%88ICP"><span class="nav-text">索引下推（ICP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-text">索引设计原则</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="nav-text">SQL优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="nav-text">插入数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#insert"><span class="nav-text">insert</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="nav-text">批量插入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E6%8E%A7%E5%88%B6%E4%BA%8B%E5%8A%A1"><span class="nav-text">手动控制事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5"><span class="nav-text">主键顺序插入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#load"><span class="nav-text">load</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD"><span class="nav-text">命令行中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#datagrip"><span class="nav-text">datagrip</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%BC%94%E7%A4%BA"><span class="nav-text">演示</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96"><span class="nav-text">主键优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E9%A1%BA%E5%BA%8F%E6%8F%92%E5%85%A5-1"><span class="nav-text">主键顺序插入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%B1%E5%BA%8F%E6%8F%92%E5%85%A5%E5%AF%BC%E8%87%B4%E9%A1%B5%E5%88%86%E8%A3%82"><span class="nav-text">乱序插入导致页分裂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E5%90%88%E5%B9%B6"><span class="nav-text">页合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96%E7%9A%84%E5%8E%9F%E5%88%99"><span class="nav-text">主键优化的原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#order-by%E4%BC%98%E5%8C%96"><span class="nav-text">order by优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%EF%BC%9A%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">附：索引的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#order-by%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="nav-text">order by优化原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gruop-by%E4%BC%98%E5%8C%96"><span class="nav-text">gruop by优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-1"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#limit%E4%BC%98%E5%8C%96"><span class="nav-text">limit优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-2"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#count%E4%BC%98%E5%8C%96"><span class="nav-text">count优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#count%E7%94%A8%E6%B3%95"><span class="nav-text">count用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-2"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#update%E4%BC%98%E5%8C%96"><span class="nav-text">update优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-3"><span class="nav-text">实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-3"><span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#where%E4%BC%98%E5%8C%96"><span class="nav-text">where优化</span></a></li></ol></li></ol>
    </div>
</div>

            </div>
        </div>
    
</main>





<!-- common js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/utils.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/header-shrink.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/back2top.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/toggle-theme.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/code-block.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/main.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/anime.min.js"></script>

<!-- local search -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/local-search.min.js"></script>


<!-- lazyload -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/lazyload.min.js"></script>


<div class="pjax">
    <!-- home page -->
    

    <!-- post page -->
    
        <!-- post-helper -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/post-helper.min.js"></script>

        <!-- toc -->
        
            <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/post/toc.min.js"></script>
        

        <!-- copyright-info -->
        

        <!-- share -->
        
    

    <!-- categories page -->
    

    <!-- links page -->
    

    <!-- photos page -->
    

    <!-- tools page -->
    
</div>

<!-- mermaid -->


<!-- pjax -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-theme-keep/4.2.5/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart()
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd()
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'))
            KEEP.initExecute()
        });
    });
</script>




    
        
    

</body>
</html>
