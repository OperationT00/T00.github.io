[{"title":"RabbitMQ","url":"/2025/07/26/RabbitMQ/","content":"基本概念消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ。\nRabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：Messaging that just works — RabbitMQ\n安装过程网上有很多，在此我就省略了。\n\n\n\n其中包含几个概念：\n\npublisher：生产者，也就是发送消息的一方\nconsumer：消费者，也就是消费消息的一方\nqueue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理\nexchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。\nvirtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue\n\n整个过程梳理下来如下：\n生产者[发送消息给交换机，交换机路由消息（并不是存储），然后决定将消息投递到某个或者某些队列]，这时，队列存储这些消息，等待消费者处理，消费者根据自身的需求和能力选择处理消息。\n&#x3D;&#x3D;注意：中括号内并不是必须的操作。&#x3D;&#x3D;\n在同一个mq集群下，可以有多个virtual host，他们之间互相隔离，有各自的exchange、queue。\n\n发送消息上面我们了解了基本过程，我们就来演示一下。\n\n创建两个queue\n\n\n\n如下：\n\n\n\n操作交换机发出消息\n\n我们将amq.fanout绑定我们刚刚创建的两个队列，并发送消息Hello,mq!。\n\n\n消息已发送！\n\n\n\n成功接收消息\n\n\n\n也可以看见消息的具体内容，也可以发现这里的消息无法更改\n\n\n\n数据隔离上面所说同一个mq集群下，可以有多个virtual host，他们之间互相隔离，有各自的exchange、queue。\n我们也可以进行验证。\n\n创建一个T00超级管理员\n\n\n\n但是这个时候，我们无法操作，队列，交换机等，因为“没有我们名下”的虚拟主机。\n\n创建虚拟主机\n\n切换成我们新创建的用户，然后创建一个虚拟主机\n\n\n他们两个虚拟主机的数据是相互隔离的\n\n\n\nSpringAMQP将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于RabbitMQ采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与RabbitMQ交互。并且RabbitMQ官方也提供了各种不同语言的客户端。\n\n\n查看官方文档，java操作MQ的hello，world都及其复杂\n\n\n\n\nSpring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。\n入门案例\n引入相关依赖\n\n使用SpringAMQP，我们要先引入相关依赖（这里是在父工程中引入的）\n&lt;!--AMQP依赖，包含RabbitMQ--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\n我们以它为父工程创建两个微服务模块来模拟消息的收发过程。\n\n\n\n配置RabbitMQ服务端信息\n\n为了方便测试，我们先新建一个simple.queue\n先配置MQ地址，在publisher服务的application.yml中添加配置\nspring:  rabbitmq:    host: 192.168.100.128 # 你的虚拟机IP    port: 5672 # 端口    virtual-host: /T00 # 虚拟主机    username: TOO # 用户名    password: 101 # 密码\n\n\n发送消息\n\nspringAMQP中封装了一个RabbitTemplate工具类，我们可以直接使用工具类来发送消息。\n@Autowiredprivate RabbitTemplate rabbitTemplate;@Testvoid testSendMessage2Queue()&#123;    String queueName = &quot;simple.queue&quot;;    String msg = &quot;helloe,mq!&quot;;    rabbitTemplate.convertAndSend(queueName,msg);&#125;\n\n直接运行，可以在控制台中找到发送的消息\n\n\n\n接收消息\n\nspringAMQP中封装了一个注解，直接在注解中queues数组中指定需要监听的队列名字即可\n@RabbitListener(queues = &quot;simple.queue&quot;)public void listenerSimpleQueue(String msg)&#123;        System.out.println(&quot;收到了消息：&quot;+ msg);    &#125;\n\n运行之后成功收到了消息\n\n\n\n这里被注解的方法的参数类型应和生产者的一致，@RabbitListener注解的作用就是将接收到的消息封装在方法的参数中。\n\n\nWorkQueues模型交换机声明队列和交换机在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。\n因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。\n基本APISpringAMQP提供了一个Queue类，用来创建队列：\n\n\nSpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：\n\n\n我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：\n\n\n而在绑定队列和交换机时，则需要使用BindingBuilder来创建Binding对象：\n\n\n\n一般这些的声明都在消费者中\n\n\n我们有两种方法声明队列和交换机\n\nnew一个对应的类，在后面指出名字即可\n\n调用builder函数\n\n\n下面我们共同使用两种办法来声明交换机和队列以及他们的绑定关系。\nfanout@Configurationpublic class FanoutConfiguration &#123;    /**     * 声明交换机     * @return Fanout类型交换机     */    @Bean    public FanoutExchange fanoutExchange()&#123;        // ExchangeBuilder.fanoutExchange(&quot;TOO.fanout2&quot;).build();        return new FanoutExchange(&quot;TOO.fanout2&quot;);    &#125;    /**     * 第1个队列     */    @Bean    public Queue fanoutQueue3()&#123;        // QueueBuilder.durable(&quot;fanout.queue3&quot;); //durable：持久的        return new Queue(&quot;fanout.queue3&quot;);  //默认持久    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1(Queue fanoutQueue3, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue3).to(fanoutExchange);    &#125;    /**     * 第2个队列     */    @Bean    public Queue fanoutQueue4()&#123;        return new Queue(&quot;fanout.queue4&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2(Queue fanoutQueue4, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue4).to(fanoutExchange);    &#125;&#125;\n\n\n运行之后，交换机、队列、绑定关系都成功声明了。\n\n\n\n\n\n\n\n\ndirect对于一个direct的交换机进行绑定操作会显得比较繁琐（因为builder函数一次只能设置一个key）\n@Configurationpublic class DirectConfiguration &#123;    /**     * 声明交换机     * @return Direct类型交换机     */    @Bean    public DirectExchange directExchange()&#123;        return ExchangeBuilder.directExchange(&quot;TOO.direct&quot;).build();    &#125;    /**     * 第1个队列     */    @Bean    public Queue directQueue1()&#123;        return new Queue(&quot;direct.queue1&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1WithRed(Queue directQueue1, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue1).to(directExchange).with(&quot;red&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1WithBlue(Queue directQueue1, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue1).to(directExchange).with(&quot;blue&quot;);    &#125;    /**     * 第2个队列     */    @Bean    public Queue directQueue2()&#123;        return new Queue(&quot;direct.queue2&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2WithRed(Queue directQueue2, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue2).to(directExchange).with(&quot;red&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2WithYellow(Queue directQueue2, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue2).to(directExchange).with(&quot;yellow&quot;);    &#125;&#125;\n\nspringAMQP中还提供了一种注解声明队列和交换机的方法。\n\n注解声明"},{"title":"MQ","url":"/2025/07/26/MQ/","content":"同步&#x2F;异步通讯首先，我们知道MQ（Message Queue，消息队列）是一种通信机制，那通讯机制又是什么呢？\n\n通讯机制又分为同步通讯和异步通讯\n同步通讯可以看作是用手机给别人打电话，双方的交互是实时的，这时可以立即得到响应，但是你却不能跟多个人同时通话。\n异步通讯就好比微信发送消息，双方的交互并不是实时的，你可以立即回复消息，也可以等一段时间回复，这样就会使得消息之间的传递有延迟，但是你还可以同时与多个人收发消息。\n\n\n\n所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用），而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。\n接下来我们再来理解一下同步调用和异步调用。\n同步调用以下根据一个支付服务对同步业务进行解析\n\n\n首先解释一下业务流程：\n\n支付服务需要先调用用户服务完成余额扣减\n然后支付服务自己要更新支付流水单的状态\n然后支付服务调用交易服务，更新业务订单状态为已支付\n\n三个步骤&#x3D;&#x3D;依次&#x3D;&#x3D;执行。\n看似没有问题，逻辑清晰，但是其中存在三个问题\n\n拓展性差\n\n如果在业务后期需要给它加入一个短信通知业务，积分业务等等。。\n\n\n每次添加业务都需要修改大量代码（不仅要在支付服务的接口中定义新的接口，新的接口又与旧的接口中有交互），非常臃肿，不符合开闭原则，拓展性不好。\n\n性能差\n\n调用者需要等待上一个服务执行完之后，有结果后，才能继续向下执行，也就是说每次调用，调用者都是处于阻塞等待状态。最终整个业务的响应时长就是每次调用的执行时长之和：\n\n\n假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了，用户都等炸毛了。\n\n级联失败\n\n\n“级联失败”（Cascading Failure）是一个在分布式系统中常见的现象，指的是一个系统中的某个组件或服务发生故障时，导致其他相关联的组件或服务也相继发生故障，从而引发整个系统的崩溃或性能大幅下降。\n\n由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。\n如果只是因为短信通知故障，导致之前收到的钱又返还了，是很得不偿失的，因为你不知道这个用户是否还会在你这里进行购物。。。。\n（OpenFeign 是一个用于简化 HTTP 请求的 Java 库，主要用于服务间的通信。它通过声明式的方式，使得开发者能够更简洁地发起 RESTful 请求，而不需要显式地编写底层的 HTTP 客户端代码。在这里不用过多了解）\n这其实就是同步调用的级联失败问题。\n针对于这三个问题，我们就必须用异步调用的方式来代替同步调用。\n异步调用异步调用方式其实就是基于&#x3D;&#x3D;消息通知&#x3D;&#x3D;的方式，一般包含三个角色：\n\n消息发送者：投递消息的人，就是原来的调用方（对应上面的例子就是支付服务）\n消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器。\n消息接收者：接收和处理消息的人，就是原来的服务提供方（对应上面的交易服务，通知服务等等。。）\n\n在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。\n然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。\n这样，发送消息的人和接收消息的人就完全解耦了。\n就好比送外卖，同步调用就是外卖小哥外卖送到了必须等你在他手上把外卖拿走了才能送下一旦，异步调用就是他送到了，直接把外卖放在外卖柜上（Broker），然后给你发个消息“外卖到了”，你也只用接收“外卖到了”这个消息就好。\n\n针对于刚刚的例子，只用在用户服务完成之后，返回支付服务发送一条消息，然后接下来的交易服务，通知服务，积分服务都只需要监听这个消息即可，他们之间是相互独立的，并发的。\n\n\n不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可，不再需要在代码中增加对其他新的业务的调用。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大&#x3D;&#x3D;提高了业务性能&#x3D;&#x3D;。\n另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低，现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务，解决了级联失败。\n同时有业务功能的添加也不需要动源代码，只需接收他们发出的消息即可，拓展性更好。\n这样的话它的压力主要集中在发送消息这一步，后续的服务可以根据自己的能力按需处理消息，相对来说很平稳，这种现象我们可以理解为削峰。\n\n\n\nMQ综上来看，MQ的本质就是一个阻塞队列， 只不过它在阻塞队列的基础上增加了重试, 消息持久化等等功能.。\n那它有什么优缺点呢？\n我们用去咖啡店买咖啡为例，如果是采用同步通讯的方法去买咖啡，我们给咖啡馆店员点餐后，我们还需要站在柜台等待他把咖啡做完，然后下一位顾客才可以进行点单，整个一条队伍把咖啡都买完的时间非常久。\n\n异步\n\n如果我们在其中运用MQ的思维，在吧台准备一个自动点餐机，用户可以在上面自行点餐，然后生成一张小票，点完之后，用户就可以走了，不用等待店员把咖啡做好，而咖啡馆店员也不用在吧台等别人来点餐，他只需要在后台备料，等有订单了，再去着手做咖啡。这就是异步。\n\n解耦\n\n在点单过后，店员就着手于做咖啡，而顾客也不用站在队伍里等候，顾客可以去上厕所，可以去买早餐，这就达到了解耦的目的。\n\n削峰\n\n在人流量很大的时候，比如早高峰，很多人都需要购买咖啡，然后不同的店员做咖啡的效率不一样，每个顾客点的咖啡做的难度也不一样，店员谁有空谁就去做下一杯，就可以避免一个店员过载导致的等待时间过长，这就是削峰。\n虽然有很多优点，但是这种模式下也会有缺点。\n\n可用性降低\n\n系统不同服务之间就靠一个MQ连接，如果MQ挂了，整个服务器就崩溃了（虽然不太可能）。\n\n复杂度更高\n\n消息的重复出现，消息是否会失效，还有顺序问题都导致了系统复杂的更高。\n\n数据一致性的问题\n\n系统中难免会发生某一个业务出现问题，就比如B,C,D三个服务都需要对同一个事务进行数据库的写入或者修改，B,C都成功了，D失败了，整个事务在数据库中的状态就不一样了，这也是需要考虑的点。\n"}]