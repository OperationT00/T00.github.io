[{"title":"RabbitMQ","url":"/2025/07/26/RabbitMQ/","content":"基本概念消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ。\nRabbitMQ是基于Erlang语言开发的开源消息通信中间件，官网地址：Messaging that just works — RabbitMQ\n安装过程网上有很多，在此我就省略了。\n\n\n\n其中包含几个概念：\n\npublisher：生产者，也就是发送消息的一方\nconsumer：消费者，也就是消费消息的一方\nqueue：队列，存储消息。生产者投递的消息会暂存在消息队列中，等待消费者处理\nexchange：交换机，负责消息路由。生产者发送的消息由交换机决定投递到哪个队列。\nvirtual host：虚拟主机，起到数据隔离的作用。每个虚拟主机相互独立，有各自的exchange、queue\n\n整个过程梳理下来如下：\n生产者[发送消息给交换机，交换机路由消息（并不是存储），然后决定将消息投递到某个或者某些队列]，这时，队列存储这些消息，等待消费者处理，消费者根据自身的需求和能力选择处理消息。\n\n注意：中括号内并不是必须的操作。\n\n在同一个mq集群下，可以有多个virtual host，他们之间互相隔离，有各自的exchange、queue。\n\n发送消息上面我们了解了基本过程，我们就来演示一下。\n\n创建两个queue\n\n\n\n如下：\n\n\n\n操作交换机发出消息\n\n我们将amq.fanout绑定我们刚刚创建的两个队列，并发送消息Hello,mq!。\n\n\n消息已发送！\n\n\n\n成功接收消息\n\n\n\n也可以看见消息的具体内容，也可以发现这里的消息无法更改\n\n\n\n数据隔离上面所说同一个mq集群下，可以有多个virtual host，他们之间互相隔离，有各自的exchange、queue。\n我们也可以进行验证。\n\n创建一个T00超级管理员\n\n\n\n但是这个时候，我们无法操作，队列，交换机等，因为“没有我们名下”的虚拟主机。\n\n创建虚拟主机\n\n切换成我们新创建的用户，然后创建一个虚拟主机\n\n\n他们两个虚拟主机的数据是相互隔离的\n\n\n\nSpringAMQP将来我们开发业务功能的时候，肯定不会在控制台收发消息，而是应该基于编程的方式。由于RabbitMQ采用了AMQP协议，因此它具备跨语言的特性。任何语言只要遵循AMQP协议收发消息，都可以与RabbitMQ交互。并且RabbitMQ官方也提供了各种不同语言的客户端。\n\n\n查看官方文档，java操作MQ的hello，world都及其复杂\n\n\n\n\nSpring的官方刚好基于RabbitMQ提供了这样一套消息收发的模板工具：SpringAMQP。并且还基于SpringBoot对其实现了自动装配，使用起来非常方便。\n入门案例\n引入相关依赖\n\n使用SpringAMQP，我们要先引入相关依赖（这里是在父工程中引入的）\n&lt;!--AMQP依赖，包含RabbitMQ--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\n我们以它为父工程创建两个微服务模块来模拟消息的收发过程。\n\n\n\n配置RabbitMQ服务端信息\n\n为了方便测试，我们先新建一个simple.queue\n先配置MQ地址，在publisher服务的application.yml中添加配置\nspring:  rabbitmq:    host: 192.168.100.128 # 你的虚拟机IP    port: 5672 # 端口    virtual-host: /T00 # 虚拟主机    username: TOO # 用户名    password: 101 # 密码\n\n\n发送消息\n\nspringAMQP中封装了一个RabbitTemplate工具类，我们可以直接使用工具类来发送消息。\n@Autowiredprivate RabbitTemplate rabbitTemplate;@Testvoid testSendMessage2Queue()&#123;    String queueName = &quot;simple.queue&quot;;    String msg = &quot;helloe,mq!&quot;;    rabbitTemplate.convertAndSend(queueName,msg);&#125;\n\n直接运行，可以在控制台中找到发送的消息\n\n\n\n接收消息\n\nspringAMQP中封装了一个注解，直接在注解中queues数组中指定需要监听的队列名字即可\n@RabbitListener(queues = &quot;simple.queue&quot;)public void listenerSimpleQueue(String msg)&#123;        System.out.println(&quot;收到了消息：&quot;+ msg);    &#125;\n\n运行之后成功收到了消息\n\n\n\n这里被注解的方法的参数类型应和生产者的一致，@RabbitListener注解的作用就是将接收到的消息封装在方法的参数中。\n\n\nWorkQueues模型Work queues，任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息，每个消息只会被一个消费者处理一次，用来实现任务的“分工处理”。\n\n\n当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。\n此时就可以使用work 模型，多个消费者共同处理消息处理，消息处理的速度就能大大提高了。\n接下来，我们就来模拟这样的场景。\n首先，我们在控制台创建一个新的队列，命名为work.queue：\n\nRabbitMQ 有两种分发模式：\n\n默认轮询发配\n\n公平发配\n\n\n\n\n我们首先模拟轮询发配\n轮询发配两个消费者性能相同\n消息发送\n\n@Testvoid testWorkQueue() throws InterruptedException &#123;    String queueName = &quot;work.queue&quot;;    for (int i = 1; i &lt;= 50; i++) &#123;        String msg = &quot;hello,worker!,message_&quot; + i;        rabbitTemplate.convertAndSend(queueName,msg);        Thread.sleep(20);    &#125;&#125;\n\n\n消息接收\n\n要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：\n@RabbitListener(queues = &quot;work.queue&quot;)public void listenerWorkQueue1(String msg)&#123;    System.out.println(&quot;消费者1 收到了消息：&quot; + msg);&#125;@RabbitListener(queues = &quot;work.queue&quot;)public void listenerWorkQueue2(String msg)&#123;    System.err.println(&quot;消费者1 收到了消息：&quot; + msg);&#125;\n\n\n运行\n\n\n\n可以看见，两个消费者如果性能一致时类似于轮询，一人消费一条消息，将消息均分了。\n两个消费者性能不同让两个消费者接收消息后停顿不同时间来实现模拟性能不同，消费者1每秒可以处理50条消息，而消费者2只能处理5条。\n@RabbitListener(queues = &quot;work.queue&quot;)public void listenerWorkQueue1(String msg) throws InterruptedException &#123;    System.out.println(&quot;消费者1 收到了消息：&quot; + msg);    Thread.sleep(20);&#125;@RabbitListener(queues = &quot;work.queue&quot;)public void listenerWorkQueue2(String msg) throws InterruptedException &#123;    System.err.println(&quot;消费者2 收到了消息：&quot; + msg);    Thread.sleep(200);&#125;\n\n结果如下：\n\n\n\n\n可以看见他们还是均分了50条消息，后面的时间全是性能比较差的消费者2在处理，性能好的消费者1反倒空闲了。\n这样显然是不合理的，浪费了系统的性能，这时我们就应该使用公平分配模式。\n公平分配公平分配通俗来讲，就是能者多劳。\n在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：\nspring:  rabbitmq:    listener:      simple:        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息\n\n这样配置之后再次运行：\n\n\n可以发现，由于消费者1处理速度较快，所以处理了更多的消息；消费者2处理速度较慢，只处理了6条消息。而最终总的执行耗时也在1秒左右，大大提升。\n这样充分利用了每一个消费者的处理能力，可以有效避免消息积压问题。\n\n交换机Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n交换机的类型有四种：\n\nFanout：广播，将消息交给所有绑定到交换机的队列。我们最早在控制台使用的正是Fanout交换机。\nDirect：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列\nTopic：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符\nHeaders：头匹配，基于MQ的消息头匹配，用的较少。\n\n接下来，我们就来一一验证。\nFanout\n准备工作\n\n\n创建一个名为 T00.fanout的交换机，类型是Fanout\n创建两个队列fanout.queue1和fanout.queue2，绑定到交换机T00.fanout\n\n\n\n过程和上面控制台发送消息一样，就略过了。\n\n消息发送\n\nfanout交换机没有这个key，传入一个空字符串即可：\n\n\n@Testpublic void testFanoutExchange() &#123;    // 交换机名称    String exchangeName = &quot;T00.fanout&quot;;    // 消息    String message = &quot;hello, everyone!&quot;;    rabbitTemplate.convertAndSend(exchangeName, &quot;&quot;, message);&#125;\n\n\n消息接收\n\n@RabbitListener(queues = &quot;fanout.queue1&quot;)public void listenerFanoutQueue1(String msg)&#123;    System.out.println(&quot;消费者1 收到了fanout.queue1消息：&quot; + msg);&#125;@RabbitListener(queues = &quot;fanout.queue2&quot;)public void listenerFanoutQueue2(String msg)&#123;    System.out.println(&quot;消费者2 收到了fanout.queue2消息：&quot; + msg);&#125;\n\n\n运行\n\n两者均接收到了消息，就如同广播一样，在广播的范围内，每个人都能收到消息。\n\n\n\nDirect在Fanout交换机中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。\nDirect交换机有以下特点：\n\n队列与交换机的绑定：不能是任意绑定了，而是要指定一个RoutingKey（路由key）\n\n消息的发送方在向 Exchange发送消息时，也必须指定消息的 RoutingKey\n\nExchange会根据绑定队列的Routingkey和所路由消息的Routingkey是否匹配，进行消息的发送，也就是是说只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息。\n\n\n\n接下来我们进行演示：\n\n准备工作\n\n\n创建一个名为T00.direct的交换机，类型是direct\n再分别创建一个Routing key为“red”，“blue”的direct.queue1和一个Routing key为“red”，“yellow”的direct.queue2\n\n\n\n\n消息发送\n\n@Testpublic void testSendDirectExchange() &#123;    // 交换机名称    String exchangeName = &quot;T00.direct&quot;;    // 消息    String message = &quot;红色&quot;;    rabbitTemplate.convertAndSend(exchangeName, &quot;red&quot;, message);&#125;\n\n@Testpublic void testSendDirectExchange() &#123;    // 交换机名称    String exchangeName = &quot;T00.direct&quot;;    // 消息    String message = &quot;蓝色&quot;;    rabbitTemplate.convertAndSend(exchangeName, &quot;bule&quot;, message);&#125;\n\n\n消息接收\n\n@RabbitListener(queues = &quot;direct.queue1&quot;)public void listenerDirectQueue1(String msg)&#123;    System.out.println(&quot;消费者1 收到了direct.queue1消息：&quot; + msg);&#125;@RabbitListener(queues = &quot;direct.queue2&quot;)public void listenerDirectQueue2(String msg)&#123;    System.out.println(&quot;消费者2 收到了direct.queue2消息：&quot; + msg);&#125;\n\n\n运行\n\n如果是red，他们都可以收到\n\n\n但是如果是blue，就只有2才能收到\n\n\n\nTopic其实Topic与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列，唯一的区别就是Topic可以让队列在绑定BindingKey 的时候使用通配符。\nBindingKey 一般都是有一个或多个单词组成，多个单词之间以.分割，例如： item.insert\n通配符规则：\n\n#：匹配一个或多个词\n*：只能匹配1个词\n\n举例：\n\nitem.#：能够匹配item.spu.insert 或者 item.spu\nitem.*：只能匹配item.spu\n\n现在我们来实现一下：\n\n\n准备工作\n\n假如此时publisher发送的消息使用的RoutingKey共有四种：\n\nchina.news 代表有中国的新闻消息；\nchina.weather 代表中国的天气消息；\njapan.news 则代表日本新闻\njapan.weather 代表日本的天气消息；\n\n解释：\n\ntopic.queue1绑定的是china.# ，凡是以 china.开头的routing key 都会被匹配到，包括：\nchina.news\nchina.weather\n\n\ntopic.queue2绑定的是#.news ，凡是以 .news结尾的 routing key 都会被匹配。包括:\nchina.news\njapan.news\n\n\n\n\n\n\n发送消息\n\n@Testpublic void testSendTopicExchange() &#123;    // 交换机名称    String exchangeName = &quot;T00.topic&quot;;    // 消息    String message = &quot;*****&quot;;    rabbitTemplate.convertAndSend(exchangeName, &quot;***&quot;, message);&#125;\n\n\n接收消息\n\n@RabbitListener(queues = &quot;topic.queue1&quot;)public void listenerTopicQueue1(String msg)&#123;    System.out.println(&quot;消费者1 收到了topic.queue1消息：&quot; + msg);&#125;@RabbitListener(queues = &quot;topic.queue2&quot;)public void listenerTopicQueue2(String msg)&#123;    System.out.println(&quot;消费者2 收到了topic.queue2消息：&quot; + msg);&#125;\n\n\n运行\n\nroutingKey为japan.news时，只有消费者2收到了消息\n\n\nroutingKey为china.news时，都收到了消息\n\n\nroutingKey为china.wether时，只有消费者1收到了消息\n\n\n符合我们的推测。\n\n声明队列和交换机在之前我们都是基于RabbitMQ控制台来创建队列、交换机。但是在实际开发时，队列和交换机是程序员定义的，将来项目上线，又要交给运维去创建。那么程序员就需要把程序中运行的所有队列和交换机都写下来，交给运维。在这个过程中是很容易出现错误的。\n因此推荐的做法是由程序启动时检查队列和交换机是否存在，如果不存在自动创建。\n基本APISpringAMQP提供了一个Queue类，用来创建队列：\n\n\nSpringAMQP还提供了一个Exchange接口，来表示所有不同类型的交换机：\n\n\n我们可以自己创建队列和交换机，不过SpringAMQP还提供了ExchangeBuilder来简化这个过程：\n\n\n而在绑定队列和交换机时，则需要使用BindingBuilder类来创建Binding对象：\n\n\n\n一般这些的声明都在消费者中\n\n\n我们有两种方法声明队列和交换机\n\nnew一个对应的类，在后面指出名字即可\n\n调用builder函数\n\n\n下面我们共同使用两种办法来声明交换机和队列以及他们的绑定关系。\nfanout@Configurationpublic class FanoutConfiguration &#123;    /**     * 声明交换机     * @return Fanout类型交换机     */    @Bean    public FanoutExchange fanoutExchange()&#123;        // ExchangeBuilder.fanoutExchange(&quot;TOO.fanout2&quot;).build();        return new FanoutExchange(&quot;TOO.fanout2&quot;);  //默认持久，至于什么是持久，下面一篇文章会进行讲解    &#125;    /**     * 第1个队列     */    @Bean    public Queue fanoutQueue3()&#123;        return new Queue(&quot;fanout.queue3&quot;);  //默认持久    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1(Queue fanoutQueue3, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue3).to(fanoutExchange);    &#125;    /**     * 第2个队列     */    @Bean    public Queue fanoutQueue4()&#123;        return new Queue(&quot;fanout.queue4&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2(Queue fanoutQueue4, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue4).to(fanoutExchange);    &#125;&#125;\n\n\n运行之后，交换机、队列、绑定关系都成功声明了。\n\n\n\n\n\n\n\n\ndirect对于一个direct的交换机进行绑定操作会显得比较繁琐（因为builder函数一次只能设置一个key）\n@Configurationpublic class DirectConfiguration &#123;    /**     * 声明交换机     * @return Direct类型交换机     */    @Bean    public DirectExchange directExchange()&#123;        return ExchangeBuilder.directExchange(&quot;TOO.direct&quot;).build();    &#125;    /**     * 第1个队列     */    @Bean    public Queue directQueue1()&#123;        return new Queue(&quot;direct.queue1&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1WithRed(Queue directQueue1, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue1).to(directExchange).with(&quot;red&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1WithBlue(Queue directQueue1, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue1).to(directExchange).with(&quot;blue&quot;);    &#125;    /**     * 第2个队列     */    @Bean    public Queue directQueue2()&#123;        return new Queue(&quot;direct.queue2&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2WithRed(Queue directQueue2, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue2).to(directExchange).with(&quot;red&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2WithYellow(Queue directQueue2, DirectExchange directExchange)&#123;        return BindingBuilder.bind(directQueue2).to(directExchange).with(&quot;yellow&quot;);    &#125;&#125;\n\nholy shit，这种声明方式好麻烦，因此伟大的springAMQP中还提供了一种注解声明队列和交换机的方法。\n\n注解声明可以在消费者注解中用bindings参数来声明队列，交换机和绑定关系，具体参数如下：\n\n\n基本框架如下：\n@RabbitListener(bindings = @QueueBinding(        value = @Queue(),        exchange = @Exchange(),        key = &#123;&#125;))\n\n我们现在删除以前于direct相关的交换机和队列，来试试用注解声明：\n@RabbitListener(bindings = @QueueBinding(        value = @Queue(name = &quot;direct.queue1&quot;,durable = &quot;true&quot;),        exchange = @Exchange(name = &quot;T00.direct&quot;,type = ExchangeTypes.DIRECT),        key = &#123;&quot;red&quot; , &quot;blue&quot;&#125;))public void listenerDirectQueue1(String msg)&#123;    System.out.println(&quot;消费者1 收到了direct.queue1消息：&quot; + msg);&#125;\n\n@RabbitListener(bindings = @QueueBinding(        value = @Queue(name = &quot;direct.queue2&quot;,durable = &quot;true&quot;),        exchange = @Exchange(name = &quot;T00.direct&quot;,type = ExchangeTypes.DIRECT),        key = &#123;&quot;red&quot; , &quot;yellow&quot;&#125;))public void listenerDirectQueue2(String msg)&#123;    System.out.println(&quot;消费者2 收到了direct.queue2消息：&quot; + msg);&#125;\n\n运行之后可以看见成功的创建了。\n\n\n\n消息转换器前面我们说到生产者发送消息的类型最好与消费者参数的类型相同，但是那是接收消息，那发送消息是否有什么限定呢？\n默认消息转换器我们先来试试它默认的消息转换器\n\n创建一个object.queue队列用于接收\n编写一个testSendObject()用于发送消息（json格式）\n\n@Testpublic void testSendObject() &#123;    Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;();    msg.put(&quot;name&quot;,&quot;jack&quot;);    msg.put(&quot;age&quot;,18);    rabbitTemplate.convertAndSend(&quot;object.queue&quot;,msg);&#125;\n\n在发送消息过后，我们来到mq的控制台查看接收到的消息：\n\n\n它并不是json格式的信息，反而是一堆看不懂的东西，这是为什么呢？\n因为它默认的消息转换器是将消息jdk序列化，jdk序列化存在安全漏洞，可读性比较差（如果以后发送的消息是一个体积很大，很复杂的json，jdk序列化的消息很难维护）的缺点，那我们有没有什么方法可以解决呢？\n答案就是我们自己配置消息转换器来替换默认的转换器。\n配置JSON转换器\n在publisher和consumer两个服务中都引入依赖（父工程中引入即可）：\n\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;    &lt;version&gt;2.9.10&lt;/version&gt;&lt;/dependency&gt;\n\n注意，如果项目中引入了spring-boot-starter-web依赖，则无需再次引入Jackson依赖。\n\n配置消息转换器：\n\n在publisher和consumer两个服务的启动类中添加一个Bean即可：\n@Beanpublic MessageConverter jacksonmessageConverter()&#123;    return new Jackson2JsonMessageConverter();&#125;\n\n再次发送，成功转换了\n\n\n\n\n\n\n\n\n\n\n"},{"title":"MQ","url":"/2025/07/26/MQ/","content":"同步&#x2F;异步通讯首先，我们知道MQ（Message Queue，消息队列）是一种通信机制，那通讯机制又是什么呢？\n\n通讯机制又分为同步通讯和异步通讯\n同步通讯可以看作是用手机给别人打电话，双方的交互是实时的，这时可以立即得到响应，但是你却不能跟多个人同时通话。\n异步通讯就好比微信发送消息，双方的交互并不是实时的，你可以立即回复消息，也可以等一段时间回复，这样就会使得消息之间的传递有延迟，但是你还可以同时与多个人收发消息。\n\n\n\n所以，如果我们的业务需要实时得到服务提供方的响应，则应该选择同步通讯（同步调用），而如果我们追求更高的效率，并且不需要实时响应，则应该选择异步通讯（异步调用）。\n接下来我们再来理解一下同步调用和异步调用。\n同步调用以下根据一个支付服务对同步业务进行解析\n\n\n首先解释一下业务流程：\n\n支付服务需要先调用用户服务完成余额扣减\n然后支付服务自己要更新支付流水单的状态\n然后支付服务调用交易服务，更新业务订单状态为已支付\n\n三个步骤依次执行。\n看似没有问题，逻辑清晰，但是其中存在三个问题\n\n拓展性差\n\n如果在业务后期需要给它加入一个短信通知业务，积分业务等等。。\n\n\n每次添加业务都需要修改大量代码（不仅要在支付服务的接口中定义新的接口，新的接口又与旧的接口中有交互），非常臃肿，不符合开闭原则，拓展性不好。\n\n性能差\n\n调用者需要等待上一个服务执行完之后，有结果后，才能继续向下执行，也就是说每次调用，调用者都是处于阻塞等待状态。最终整个业务的响应时长就是每次调用的执行时长之和：\n\n\n假如每个微服务的执行时长都是50ms，则最终整个业务的耗时可能高达300ms，性能太差了，用户都等炸毛了。\n\n级联失败\n\n\n“级联失败”（Cascading Failure）是一个在分布式系统中常见的现象，指的是一个系统中的某个组件或服务发生故障时，导致其他相关联的组件或服务也相继发生故障，从而引发整个系统的崩溃或性能大幅下降。\n\n由于我们是基于OpenFeign调用交易服务、通知服务。当交易服务、通知服务出现故障时，整个事务都会回滚，交易失败。\n如果只是因为短信通知故障，导致之前收到的钱又返还了，是很得不偿失的，因为你不知道这个用户是否还会在你这里进行购物。。。。\n（OpenFeign 是一个用于简化 HTTP 请求的 Java 库，主要用于服务间的通信。它通过声明式的方式，使得开发者能够更简洁地发起 RESTful 请求，而不需要显式地编写底层的 HTTP 客户端代码。在这里不用过多了解）\n这其实就是同步调用的级联失败问题。\n针对于这三个问题，我们就必须用异步调用的方式来代替同步调用。\n异步调用异步调用方式其实就是基于消息通知的方式，一般包含三个角色：\n\n消息发送者：投递消息的人，就是原来的调用方（对应上面的例子就是支付服务）\n消息Broker：管理、暂存、转发消息，你可以把它理解成微信服务器。\n消息接收者：接收和处理消息的人，就是原来的服务提供方（对应上面的交易服务，通知服务等等。。）\n\n在异步调用中，发送者不再直接同步调用接收者的业务接口，而是发送一条消息投递给消息Broker。\n然后接收者根据自己的需求从消息Broker那里订阅消息。每当发送方发送消息后，接受者都能获取消息并处理。\n这样，发送消息的人和接收消息的人就完全解耦了。\n就好比送外卖，同步调用就是外卖小哥外卖送到了必须等你在他手上把外卖拿走了才能送下一旦，异步调用就是他送到了，直接把外卖放在外卖柜上（Broker），然后给你发个消息“外卖到了”，你也只用接收“外卖到了”这个消息就好。\n\n针对于刚刚的例子，只用在用户服务完成之后，返回支付服务发送一条消息，然后接下来的交易服务，通知服务，积分服务都只需要监听这个消息即可，他们之间是相互独立的，并发的。\n\n\n不管后期增加了多少消息订阅者，作为支付服务来讲，执行问扣减余额、更新支付流水状态后，发送消息即可，不再需要在代码中增加对其他新的业务的调用。业务耗时仅仅是这三部分业务耗时，仅仅100ms，大大提高了业务性能。\n另外，不管是交易服务、通知服务，还是积分服务，他们的业务与支付关联度低，现在采用了异步调用，解除了耦合，他们即便执行过程中出现了故障，也不会影响到支付服务，解决了级联失败。\n同时有业务功能的添加也不需要动源代码，只需接收他们发出的消息即可，拓展性更好。\n这样的话它的压力主要集中在发送消息这一步，后续的服务可以根据自己的能力按需处理消息，相对来说很平稳，这种现象我们可以理解为削峰。\n\n\n\nMQ综上来看，MQ的本质就是一个阻塞队列， 只不过它在阻塞队列的基础上增加了重试, 消息持久化等等功能.。\n那它有什么优缺点呢？\n我们用去咖啡店买咖啡为例，如果是采用同步通讯的方法去买咖啡，我们给咖啡馆店员点餐后，我们还需要站在柜台等待他把咖啡做完，然后下一位顾客才可以进行点单，整个一条队伍把咖啡都买完的时间非常久。\n\n异步\n\n如果我们在其中运用MQ的思维，在吧台准备一个自动点餐机，用户可以在上面自行点餐，然后生成一张小票，点完之后，用户就可以走了，不用等待店员把咖啡做好，而咖啡馆店员也不用在吧台等别人来点餐，他只需要在后台备料，等有订单了，再去着手做咖啡。这就是异步。\n\n解耦\n\n在点单过后，店员就着手于做咖啡，而顾客也不用站在队伍里等候，顾客可以去上厕所，可以去买早餐，这就达到了解耦的目的。\n\n削峰\n\n在人流量很大的时候，比如早高峰，很多人都需要购买咖啡，然后不同的店员做咖啡的效率不一样，每个顾客点的咖啡做的难度也不一样，店员谁有空谁就去做下一杯，就可以避免一个店员过载导致的等待时间过长，这就是削峰。\n虽然有很多优点，但是这种模式下也会有缺点。\n\n可用性降低\n\n系统不同服务之间就靠一个MQ连接，如果MQ挂了，整个服务器就崩溃了（虽然不太可能）。\n\n复杂度更高\n\n消息的重复出现，消息是否会失效，还有顺序问题都导致了系统复杂的更高。\n\n数据一致性的问题\n\n系统中难免会发生某一个业务出现问题，就比如B,C,D三个服务都需要对同一个事务进行数据库的写入或者修改，B,C都成功了，D失败了，整个事务在数据库中的状态就不一样了，这也是需要考虑的点。\n"}]